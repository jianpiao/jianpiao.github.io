{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{331:function(t,e,a){\"use strict\";a.r(e);var r=a(33),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"react技术积累\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react技术积累\"}},[t._v(\"#\")]),t._v(\" React技术积累\")]),t._v(\" \"),a(\"p\",[t._v(\"学无止境，未来的路，就开技术的堆积和挑战！面试的坎不止一次，要学习总结和积累。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"react-hook和vue3-0对比\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react-hook和vue3-0对比\"}},[t._v(\"#\")]),t._v(\" react hook和vue3.0对比\")]),t._v(\" \"),a(\"p\",[t._v(\"参考链接1：\"),a(\"a\",{attrs:{href:\"https://zhuanlan.zhihu.com/p/133819602\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Vue3 究竟好在哪里？（和 React Hook 的详细对比）\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"参考链接2:\"),a(\"a\",{attrs:{href:\"https://juejin.im/post/6844903877574295560\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"精读《Vue3.0 Function API》 \"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"div\",{staticClass:\"language-javascript extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"export\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"default\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"function\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"Counter\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"const\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),t._v(\"count\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" setCount\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"useState\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"const\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function-variable function\"}},[t._v(\"add\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"setCount\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"prev\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" prev \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 下文讲解用\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"const\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),t._v(\"count2\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" setCount2\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"useState\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"div\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n      \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"span\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"count\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"span\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n      \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"button onClick\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"add\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"button\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"div\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\\n\")])])]),a(\"p\",[t._v(\"它是一个函数，而父组件引入它是通过 \"),a(\"code\",[t._v(\"<Counter />\")]),t._v(\" 这种方式引入的，实际上它会被编译成 \"),a(\"code\",[t._v(\"React.createElement(Counter)\")]),t._v(\" 这样的函数执行，也就是说每次渲染，这个函数都会被完整的执行一次。\")]),t._v(\" \"),a(\"p\",[t._v(\"而 \"),a(\"code\",[t._v(\"useState\")]),t._v(\" 返回的 \"),a(\"code\",[t._v(\"count\")]),t._v(\" 和 \"),a(\"code\",[t._v(\"setCount\")]),t._v(\" 则会被保存在组件对应的 \"),a(\"code\",[t._v(\"Fiber\")]),t._v(\" 节点上，每个 React 函数每次执行 Hook 的顺序必须是相同的，举例来说。 这个例子里的 \"),a(\"code\",[t._v(\"useState\")]),t._v(\" 在初次执行的时候，由于执行了两次 \"),a(\"code\",[t._v(\"useState\")]),t._v(\"，会在 \"),a(\"code\",[t._v(\"Fiber\")]),t._v(\" 上保存一个 \"),a(\"code\",[t._v(\"{ value, setValue } -> { value2, setValue2 }\")]),t._v(\" 这样的链表结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"而下一次渲染又会执行 \"),a(\"code\",[t._v(\"count 的 useState\")]),t._v(\"、 \"),a(\"code\",[t._v(\"count2 的 useState\")]),t._v(\"，那么 React 如何从 \"),a(\"code\",[t._v(\"Fiber\")]),t._v(\" 节点上找出上次渲染保留下来的值呢？当然是只能按顺序找啦。\")]),t._v(\" \"),a(\"p\",[t._v(\"第一次执行的 useState 就拿到第一个 \"),a(\"code\",[t._v(\"{ value, setValue }\")]),t._v(\"，第二个执行的就拿到第二个 \"),a(\"code\",[t._v(\"{ value2, setValue2 }\")]),t._v(\"，\")]),t._v(\" \"),a(\"p\",[t._v(\"这也就是为什么 React 严格限制 Hook 的执行顺序和禁止条件调用。\")]),t._v(\" \"),a(\"p\",[t._v(\"假如第一次渲染执行两次 useState，而第二次渲染时第一个 useState 被 if 条件判断给取消掉了，那么第二个 \"),a(\"code\",[t._v(\"count2 的 useState\")]),t._v(\" 就会拿到链表中第一条的值，完全混乱了。\")]),t._v(\" \"),a(\"p\",[t._v(\"如果在 React 中，要监听 \"),a(\"code\",[t._v(\"count\")]),t._v(\" 的变化做某些事的话，会用到 \"),a(\"code\",[t._v(\"useEffect\")]),t._v(\" 的话，那么下次 \"),a(\"code\",[t._v(\"render\")])]),t._v(\" \"),a(\"p\",[t._v(\"之后会把前后两次 \"),a(\"code\",[t._v(\"render\")]),t._v(\" 中拿到的 \"),a(\"code\",[t._v(\"useEffect\")]),t._v(\" 的第二个参数 \"),a(\"code\",[t._v(\"deps\")]),t._v(\" 依赖值进行一个逐项的浅对比（对前后每一项依次调用 Object.is），比如\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-javascript extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"export\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"default\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"function\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"Counter\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"const\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),t._v(\"count\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" setCount\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"useState\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"const\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function-variable function\"}},[t._v(\"add\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"setCount\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"prev\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" prev \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"useEffect\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=>\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    console\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"count updated!\"')]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" count\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),t._v(\"count\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"div\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n      \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"span\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"count\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"span\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n      \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"button onClick\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"add\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"button\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"div\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\\n\")])])]),a(\"p\",[t._v(\"那么，当 React 在渲染后发现 \"),a(\"code\",[t._v(\"count\")]),t._v(\" 发生了变化，会执行 \"),a(\"code\",[t._v(\"useEffect\")]),t._v(\" 中的回调函数。（细心的你可以观察出来，每次渲染都会重新产生一个函数引用，也就是 useEffect 的第一个参数）。\")]),t._v(\" \"),a(\"p\",[t._v(\"是的，React 还是不可避免的引入了 \"),a(\"code\",[t._v(\"依赖\")]),t._v(\" 这个概念，但是这个 \"),a(\"code\",[t._v(\"依赖\")]),t._v(\" 是需要我们去手动书写的，实时上 React 社区所讨论的「心智负担」也基本上是由于这个 \"),a(\"code\",[t._v(\"依赖\")]),t._v(\" 所引起的……\")]),t._v(\" \"),a(\"p\",[t._v(\"由于每次渲染都会不断的执行并产生闭包，那么从性能上和 GC 压力上都会稍逊于 Vue3。它的关键字是「每次渲染都重新执行」。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"react组件生命周期\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react组件生命周期\"}},[t._v(\"#\")]),t._v(\" react组件生命周期\")]),t._v(\" \"),a(\"p\",[t._v(\"react组件进入到离开需要经历一些列的生命周期方法，下面就是\"),a(\"code\",[t._v(\"class\")]),t._v(\"模式下的生命周期函数，在17版本之后有些会被弃用：\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_1-constructor\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-constructor\"}},[t._v(\"#\")]),t._v(\" 1. constructor()\")]),t._v(\" \"),a(\"p\",[t._v(\"构造函数执行，初始化数据，\"),a(\"code\",[t._v(\"super\")]),t._v(\"继承数据。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_2-componentwillmount\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-componentwillmount\"}},[t._v(\"#\")]),t._v(\" 2. componentWillMount()\")]),t._v(\" \"),a(\"p\",[t._v(\"在渲染前调用,在客户端也在服务端，它只发生一次。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_3-render\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-render\"}},[t._v(\"#\")]),t._v(\" 3.render\")]),t._v(\" \"),a(\"p\",[t._v(\"页面初始化渲染一次，后面挂载的时候也会被执行。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_4-componentdidmount\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-componentdidmount\"}},[t._v(\"#\")]),t._v(\" 4. componentDidMount()\")]),t._v(\" \"),a(\"p\",[t._v(\"在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过\"),a(\"code\",[t._v(\"this.getDOMNode()\")]),t._v(\"来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用\"),a(\"code\",[t._v(\"setTimeout\")]),t._v(\", \"),a(\"code\",[t._v(\"setInterval\")]),t._v(\"或者发送AJAX请求等操作(防止异部操作阻塞UI)。\")]),t._v(\" \"),a(\"p\",[t._v(\"在这前\"),a(\"code\",[t._v(\"render\")]),t._v(\"函数已经执行一遍了。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_5-componentwillreceiveprops\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-componentwillreceiveprops\"}},[t._v(\"#\")]),t._v(\" 5. componentWillReceiveProps()\")]),t._v(\" \"),a(\"p\",[t._v(\"在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_6-shouldcomponentupdate\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-shouldcomponentupdate\"}},[t._v(\"#\")]),t._v(\" 6. shouldComponentUpdate()\")]),t._v(\" \"),a(\"p\",[t._v(\"返回一个布尔值。在组件接收到新的\"),a(\"code\",[t._v(\"props\")]),t._v(\"或者\"),a(\"code\",[t._v(\"state\")]),t._v(\"时被调用。在初始化时或者使用\"),a(\"code\",[t._v(\"forceUpdate\")]),t._v(\"时不被调用。 可以在你确认不需要更新组件时使用。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_7-componentwillupdate\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-componentwillupdate\"}},[t._v(\"#\")]),t._v(\" 7. componentWillUpdate()\")]),t._v(\" \"),a(\"p\",[t._v(\"在组件接收到新的\"),a(\"code\",[t._v(\"props\")]),t._v(\"或者\"),a(\"code\",[t._v(\"state\")]),t._v(\"但还没有\"),a(\"code\",[t._v(\"render\")]),t._v(\"时被调用。在初始化时不会被调用。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_8-componentdidupdate\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-componentdidupdate\"}},[t._v(\"#\")]),t._v(\" 8. componentDidUpdate()\")]),t._v(\" \"),a(\"p\",[t._v(\"在组件完成更新后立即调用。在初始化时不会被调用。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_9-componentwillunmount\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-componentwillunmount\"}},[t._v(\"#\")]),t._v(\" 9. componentWillUnMount()\")]),t._v(\" \"),a(\"p\",[t._v(\"组件从 DOM 中移除的时候立刻被调用。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"未来版本中有三个生命周期会弃用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#未来版本中有三个生命周期会弃用\"}},[t._v(\"#\")]),t._v(\" 未来版本中有三个生命周期会弃用\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_1-componentwillmound\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-componentwillmound\"}},[t._v(\"#\")]),t._v(\" 1. componentWillMound\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"注意\")]),t._v(\" \"),a(\"p\",[t._v(\"此生命周期之前名为 \"),a(\"code\",[t._v(\"componentWillMount\")]),t._v(\"。该名称将继续使用至 React 17。可以使用 \"),a(\"a\",{attrs:{href:\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"rename-unsafe-lifecycles\")]),t._v(\" codemod\"),a(\"OutboundLink\")],1),t._v(\" 自动更新你的组件。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"code\",[t._v(\"UNSAFE_componentWillMount()\")]),t._v(\" 在挂载之前被调用。它在 \"),a(\"code\",[t._v(\"render()\")]),t._v(\" 之前调用，因此在此方法中同步调用 \"),a(\"code\",[t._v(\"setState()\")]),t._v(\" 不会触发额外渲染。通常，我们建议使用 \"),a(\"code\",[t._v(\"constructor()\")]),t._v(\" 来初始化 state。\")]),t._v(\" \"),a(\"p\",[t._v(\"避免在此方法中引入任何副作用或订阅。如遇此种情况，请改用 \"),a(\"code\",[t._v(\"componentDidMount()\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"此方法是服务端渲染唯一会调用的生命周期函数。\")])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_2-componentwillreceiveprops\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-componentwillreceiveprops\"}},[t._v(\"#\")]),t._v(\" 2. componentWillReceiveProps()\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"此生命周期之前名为 \"),a(\"code\",[t._v(\"componentWillReceiveProps\")]),t._v(\"。该名称将继续使用至 React 17。可以使用 \"),a(\"a\",{attrs:{href:\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"rename-unsafe-lifecycles\")]),t._v(\" codemod\"),a(\"OutboundLink\")],1),t._v(\" 自动更新你的组件。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"注意:\")]),t._v(\" \"),a(\"p\",[t._v(\"使用此生命周期方法通常会出现 bug 和不一致性：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"如果你需要\"),a(\"strong\",[t._v(\"执行副作用\")]),t._v(\"（例如，数据提取或动画）以响应 props 中的更改，请改用 \"),a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#componentdidupdate\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"componentDidUpdate\")]),a(\"OutboundLink\")],1),t._v(\" 生命周期。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果你使用 \"),a(\"code\",[t._v(\"componentWillReceiveProps\")]),t._v(\" \"),a(\"strong\",[t._v(\"仅在 prop 更改时重新计算某些数据\")]),t._v(\"，请\"),a(\"a\",{attrs:{href:\"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"使用 memoization helper 代替\"),a(\"OutboundLink\")],1),t._v(\"。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果你使用 \"),a(\"code\",[t._v(\"componentWillReceiveProps\")]),t._v(\" 是为了\"),a(\"strong\",[t._v(\"在 prop 更改时“重置”某些 state\")]),t._v(\"，请考虑使组件\"),a(\"a\",{attrs:{href:\"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"完全受控\"),a(\"OutboundLink\")],1),t._v(\"或\"),a(\"a\",{attrs:{href:\"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"使用 \"),a(\"code\",[t._v(\"key\")]),t._v(\" 使组件完全不受控\"),a(\"OutboundLink\")],1),t._v(\" 代替。\")])]),t._v(\" \"),a(\"p\",[t._v(\"对于其他使用场景，\"),a(\"a\",{attrs:{href:\"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"请遵循此博客文章中有关派生状态的建议\"),a(\"OutboundLink\")],1),t._v(\"。\")])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_3-componentwillupdate\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-componentwillupdate\"}},[t._v(\"#\")]),t._v(\" 3.componentWillUpdate()\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"strong\",[t._v(\"注意\")])]),t._v(\" \"),a(\"p\",[t._v(\"此生命周期之前名为 \"),a(\"code\",[t._v(\"componentWillUpdate\")]),t._v(\"。该名称将继续使用至 React 17。可以使用 \"),a(\"a\",{attrs:{href:\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"rename-unsafe-lifecycles\")]),t._v(\" codemod\"),a(\"OutboundLink\")],1),t._v(\" 自动更新你的组件。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"当组件收到新的 props 或 state 时，会在渲染之前调用 \"),a(\"code\",[t._v(\"UNSAFE_componentWillUpdate()\")]),t._v(\"。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。\")]),t._v(\" \"),a(\"p\",[t._v(\"注意，你不能此方法中调用 \"),a(\"code\",[t._v(\"this.setState()\")]),t._v(\"；在 \"),a(\"code\",[t._v(\"UNSAFE_componentWillUpdate()\")]),t._v(\" 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新\")]),t._v(\" \"),a(\"p\",[t._v(\"通常，此方法可以替换为 \"),a(\"code\",[t._v(\"componentDidUpdate()\")]),t._v(\"。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 \"),a(\"code\",[t._v(\"getSnapshotBeforeUpdate()\")]),t._v(\" 中。\")])]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"查看react的生命周期\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"react官网生命周期介绍\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"h3\",{attrs:{id:\"react17-0组件的生命周期\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react17-0组件的生命周期\"}},[t._v(\"#\")]),t._v(\" react17.0组件的生命周期\")]),t._v(\" \"),a(\"p\",[t._v(\"每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。\"),a(\"strong\",[t._v(\"你可以使用此\"),a(\"a\",{attrs:{href:\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"生命周期图谱\"),a(\"OutboundLink\")],1),t._v(\"作为速查表\")]),t._v(\"。在下述列表中，常用的生命周期方法会被加粗。其余生命周期函数的使用则相对罕见。\")]),t._v(\" \"),a(\"p\",[t._v(\"当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"挂载\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#挂载\"}},[t._v(\"#\")]),t._v(\" 挂载\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#constructor\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"strong\",[a(\"code\",[t._v(\"constructor()\")])]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"static getDerivedStateFromProps()\")]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#render\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"strong\",[a(\"code\",[t._v(\"render()\")])]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#componentdidmount\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"strong\",[a(\"code\",[t._v(\"componentDidMount()\")])]),a(\"OutboundLink\")],1)])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"更新\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#更新\"}},[t._v(\"#\")]),t._v(\" 更新\")]),t._v(\" \"),a(\"p\",[t._v(\"当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"static getDerivedStateFromProps()\")]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#shouldcomponentupdate\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"shouldComponentUpdate()\")]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#render\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"strong\",[a(\"code\",[t._v(\"render()\")])]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#getsnapshotbeforeupdate\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"getSnapshotBeforeUpdate()\")]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#componentdidupdate\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"strong\",[a(\"code\",[t._v(\"componentDidUpdate()\")])]),a(\"OutboundLink\")],1)])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"卸载\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#卸载\"}},[t._v(\"#\")]),t._v(\" 卸载\")]),t._v(\" \"),a(\"p\",[t._v(\"当组件从 DOM 中移除时会调用如下方法：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#componentwillunmount\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"strong\",[a(\"code\",[t._v(\"componentWillUnmount()\")])]),a(\"OutboundLink\")],1)])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"错误处理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#错误处理\"}},[t._v(\"#\")]),t._v(\" 错误处理\")]),t._v(\" \"),a(\"p\",[t._v(\"当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromerror\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"static getDerivedStateFromError()\")]),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://react.docschina.org/docs/react-component.html#componentdidcatch\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a(\"code\",[t._v(\"componentDidCatch()\")]),a(\"OutboundLink\")],1)])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#\"}},[t._v(\"#\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"setstate更新是同步还是异步\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#setstate更新是同步还是异步\"}},[t._v(\"#\")]),t._v(\" setState更新是同步还是异步\")]),t._v(\" \"),a(\"p\",[t._v(\"看待这个更新同步或者异步需要看执行环境。\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[a(\"code\",[t._v(\"setState\")]),t._v(\"只在合成事件和钩子函数中是“异步”的，在原生事件和\"),a(\"code\",[t._v(\"setTimeout\")]),t._v(\" 中都是同步的。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"code\",[t._v(\"setState\")]),t._v(\" 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 \"),a(\"code\",[t._v(\"setState(partialState, callback)\")]),t._v(\" 中的\"),a(\"code\",[t._v(\"callback\")]),t._v(\"拿到更新后的结果。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"code\",[t._v(\"setState\")]),t._v(\" 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次\"),a(\"code\",[t._v(\"setState\")]),t._v(\"，\"),a(\"code\",[t._v(\"setState\")]),t._v(\"的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时\"),a(\"code\",[t._v(\"setState\")]),t._v(\"多个不同的值，在更新时会对其进行合并批量更新。\")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);","extractedComments":[]}