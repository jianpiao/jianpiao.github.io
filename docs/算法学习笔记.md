## 二分查找

假设要在电话簿中找一个名字以K打头的人，(现在谁还用电话簿!) 可以从头开始翻页，直到进入以K打头的部分。但你很可能不这样做，而 是从中间开始，因为你知道以K打头的名字在电话簿中间。

又假设要在字典中找一个以O打头的单词，你也将从中间附近开始。

现在假设你登录Facebook。当你这样做时，Facebook必须核实你是 否有其网站的账户，因此必须在其数据库中查找你的用户名。如果你的 用户名为karlmageddon，Facebook可从以A打头的部分开始查找，但更合 乎逻辑的做法是从中间开始查找。

这是一个查找问题，在前述所有情况下，都可使用同一种算法来解 决问题，这种算法就是**二分查找**。

#### 下面的示例说明了二分查找的工作原理。我随便想一个1~100的数字。

> 你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。 假设你从1开始依次往上猜。
>
> 1 (小了)
>
> 2 (小了)
>
> ...........
>
> 49(小了)

这是简单查找，更准确的说法是傻找。每次猜测都只能排除一个数字。如果我想的数字是99， 你得猜99次才能猜到!

##### 更佳的查找方式

> 从 50 开始。
>
> 50 (小了，但排除了一半的数字!至此，你知道1~50都小了。接下来，你猜75。)
>
> 75  (大了，那余下的数字又排除了一半!使用二分查找时，你猜测的是中间的数字，从而每次都 将余下的数字排除一半。接下来，你猜63(50和75中间的数字)。)

##### 100个元素-->50-->25-->13-->7-->4-->2-->1

> 不管我心里想的是哪个数字，你在7次之内都能猜到，因为每次 猜测都将排除很多数字!

假设你要在字典中查找一个单词，而该字典包含240 000个单词， 你认为每种查找最多需要多少步?

答案是18步。

对于包含n个元素的列表，用二分查

找最多需要log2n步，而简单查找最多需要n步。

#### javascript实现二分查找

> 二分查找需要注意的是，只能用在有序列表里面，所以使用之前要确保数组内容是有序的。

```javascript
    /**
    *  二分查找
    *  @param list - 数组
    *  @param item - 查找的值
    */
    function binary_search(list, item) {
      let low = 0
      let high = list.length - 1
      let mid, guess;

      while (low <= high) {
        mid = Math.floor((low + high) / 2); // 取中间的索引下标，如果是奇数则向下取整
        guess = list[mid];  // 取中间的值
        console.log(mid, guess)
        if (guess == item) {
          return mid // 猜对了
        }
        if (guess > item) {
          high = mid - 1  // 猜大了
        } else {
          low = mid + 1  // 猜小了
        }
      }
      return '没有元素'
    }

    // 数组
    let arr = Array.from(Array(100), (item, index) => {
      return index + 1
    })

    console.log(binary_search(['a', 'b', 'c', 'd', 'e', 'f'], 'd')) // 3
    console.log(binary_search(['a', 'b', 'c', 'd', 'e', 'f'], 'g')) // 没有元素
    console.log(binary_search(arr, 9)) // 8
```

### 运行时间

每次介绍算法时，我都将讨论其运行时间。一般而言，应选择效率最高的算 法，以最大限度地减少运行时间或占用空间。

回到前面的二分查找。使用它可节省多少时间呢?简单查找逐个地检查数 字，如果列表包含100个数字，最多需要猜100次。如果列表包含40亿个数字，最 多需要猜40亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为线性 时间(linear time)。

二分查找则不同。如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?

所以二分查找的速度为 `O(log n)`,也叫对数时间。

### 小结

1. 二分查找的速度比简单查找快得多。
2. O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
3. 算法运行时间并不以秒为单位。
4. 算法运行时间是从其增速的角度度量的。
5. 算法运行时间用大O表示法表示。

## 选择排序

选择排序是一种灵巧的算法，也是代码非常简单，非常易于理解代码的一种排序算法，通常情况下直接两个for循环比较大小，交换位置，或者将小（大）的添加到新的数组，即可完成选择排序算法。但其速度不是很快。**快速排序**是一种更快的排序算法，其运行 时间为**O(n log n)**。

```javascript
   /**
   *  选择排序
   *  @param arr - 数组
   */
    function selectionSort(arr) {
      let minIndex; // 最小值下标
      for (let i = 0; i < arr.length; i++) {
        minIndex = i // 随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个
        for (let j = i + 1; j < arr.length; j++) {
          if (arr[j] < arr[minIndex]) {
            minIndex = j
          }
        }
        // es6的解构赋值
        [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]
      }
      return arr
    }

    console.log(selectionSort([5, 3, 6, 2, 10])) // [2, 3, 5, 6, 10]
```

可视化的选择排序可以参考如下地址

[visualgo可视化排序](https://visualgo.net/zh/sorting)

## 阶乘算法-递归

假设要计算5的阶乘，我们使用很多方法，比如循环发，比如递归，这次就讲讲递归的实现。

数的阶乘，定位的n!,表示从1到n的整数的乘积。

5的阶乘表示为5！，等同于 5 * 4 * 3 * 2 * 1，结果是120；

### 迭代阶乘n

如果尝试表示计算任意数n的阶乘的步骤，可以将步骤定义如下：`(n) * (n - 1) * (n - 2) * ... * (n - (n-1))`

可以循环写一个计算阶乘的函数：如下

```javascript
function factorial(number){
  if(number < 0) return undefined;
  let total = 1;
  for(let n=number; n > 1; n--){
    total  = total * n
  }
  return total
}

console.log(factorial(5))  // 120
```

我们可以从给定的number开始计算阶乘，并减少n，直到它的值为2，因为1的阶乘还是1，而且它已经被包含在total变量中了。0的阶乘也是1，负数的阶乘不会被计算。

### 递归阶乘

我们通过递归的方式重写上面的例子。

```javascript
function factorial(n) {
  if (n === 1 || n === 0) {  // 基线条件
    return 1
  }
  return n * factorial(n - 1)  // 递归调用
}

console.log(factorial(5)) // 120
```

### 调用栈

每当一个函数被一个算法调用时，该函数会进入**调用栈**的顶部。当使用递归的时候，每个函数调用都会堆叠在调用栈的顶部，这个是因为每个调用都可以依赖前一个调用结果。

上面的递归案例执行顺序如下：

1. 执行
2. `factorial(5)`
3.  `5 * factorial(4)`
4. `5 * 4 * factorial(3)`
5. `5 * 4 * 3 * factorial(2)`
6. `5 * 4 * 3 * 2 * factorial(1)`
7. `5 * 4 * 3 * 2 * 1`
8. 结束，结果为 120

### JavaScript调用栈大小的限制

如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限的执行下去，浏览器会抛出错误，也就是所谓的**栈溢出错误(stack overflow error)**

每一个浏览器都有自己的上限，可以用下面代码测试：

```javascript
let i = 0;
function recursive() {
  i++;
  recursive()
}

try {
  recursive()
} catch (error) {
  console.log('i = ' + i + ' 抛出错误: ' + error)
}
```

我自己使用的是谷歌浏览器，**版本 83.0.4103.116（正式版本） （64 位）**最后的结果是`i = 15676 抛出错误: RangeError: Maximum call stack size exceeded`;

ES6有**尾部调用优化(tail call optimization)**如果函数内的最后一个操作的调用函数，比如上面的`recursive()`会通过**跳转指令(jump)**而不是子程序调用来控制。也就是说，在ES6中，这里的代码可以一直执行下去，因此，具有停止递归的基线条件是非常重要的。

## 排序算法稳定性速记

不稳定的算法：快（快速排序）、些（希尔排序）、选（选择排序）、队（堆排序） 

平均时间复杂度为O(nlog2n)：快速排序、归并排序、堆排序

## 格式化整数型为千分位

```javascript
/**
 * 格式化整数型为千分位
 * 输出为整数
 * 如输入：123456789
 * 输出：123,456,789
*/
function formatNumber(num = "") {
  num = num.toString()
  let len = num.split("").length;
  let arr = []
  let count = 0
  for (let i = len - 1; i >= 0; i--) {
    count++
    arr.unshift(num[i])
    if (!(count % 3) && i != 0) {
      arr.unshift(",")
    }
  }
  return arr.join("")
}
```

## 按照顺序取新数组y，y在区间[min,max]中有多少种可能性

```javascript
/**
 * 按照顺序取新数组y，y在区间[min,max]中有多少种可能性
 * 输入[1, 4, 7, 3]
 * 输出 4种 
 * 四种如下： [1] [4] [1,4] [3]
 */

function getSubArr(array, min, max) {
  let count = 0;
  let last = 0;
  let state = true;
  array.forEach((item, index) => {
    state = true;
    last = 0;
    while (state) {
      if (array[index - last] && array[index - last] >= min && array[index - last] <= max) {
        count += 1;
        last--;
        state = true
      } else {
        state = false
      }
    }
  });
  return count
}
```

## 取数组不重复位置最长的次数

```javascript
/**
 * 取数组不重复位置最长的次数
 * @param {string} str 
 */
function getMax(str) {
  let num = 0
  let max = 0
  let obj = {}
  str = str.split("");
  str.reduce((a, b) => {
    if (!obj[b]) {
      obj[b] = b
      num += 1
      if (num > max) {
        max = num
      }
    } else {
      num = 1
    }
  })
  return max
}

console.log(getMax('abcabc'))  // 3
console.log(getMax('123112'))  // 3
console.log(getMax('xxxx'))  // 1
console.log(getMax('xllenl'))  // 3
```

## 有一个 m 行 n 列的矩阵地图，起点位于左上角，终点位于右下角。

这里需要使用动态规划。

```javascript
/**
 * 有一个 m 行 n 列的矩阵地图，起点位于左上角，终点位于右下角。
 * 
 * 一只小马要从起点走到终点，而且每一步只能往前走（往右或往下），不能往回走。
 * 
 * 实现一个算法，输入 m 和 n，输出有多少条不同的路可以实现机器马的目标。
 * 
 * 比如：
 * 输入: m = 2, n = 3 输出 3
 * 解释：
 * 1. 右 -> 右 -> 下
 * 2. 右 -> 下 -> 右
 * 3. 下 -> 右 -> 右
 * 
 * 输入：m = 3, n = 6 输出 21
 */

/**
 * @param {number} m 行数
 * @param {number} n 列数
 * @return {number} 路径条数
 */
var paths = function (m, n) {
  let count = 0
  if (m == 1 || n == 1) {
    count = 1
  } else {
    count = paths(m - 1, n) + paths(m, n - 1)
  }
  return count
};
```

## 查找路径

输入描述

> 一个路径集合，每个路径只由/和小写字母结合，且不会出现多个/重叠的情况，所有路径都是以/开头，不以/结尾，而且不会出现单个/，都会组合字母多个路径以逗号，分割

输出描述

> 输出多个结果使用逗号分割
>
> 输出结果需要与原顺序一致
>
> 不存在时输出false

```javascript
function findPath(map) {
  let result = []
  let obj = {}
  for (let i in map) {
    for (let key in map) {
      if (map[key].indexOf(map[i]) > -1) {
        let temp = map[key].replace(map[i], "|-")
        let value = temp.split("-")
        if (value[0] == '|' && value[1]) {
          map[key] in obj ? null : obj[map[i]] = map[i]
        }
      }
    }
  }
  for (let key in obj) {
    if (obj[key]) {
      result.push(obj[key])
    }
  }
  return result.length > 0 ? result.toString() : false
}

console.log(findPath(['/a', '/a/b', '/a/c', '/b/c', '/b/c/d', '/b/cf']))
```

## 给定一个数组arr，返回子数组的最大累加和

#### 题目描述

给定一个数组arr，返回子数组的最大累加和 

例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.

#### [要求] 

时间复杂度为O(n)*O*(*n*)，空间复杂度为O(1)*O*(1)

实例1：

> 输入 [1, -2, 3, 5, -2, 6, -1]

> 输出 12

```javascript
function getMax(arr) {
  if (arr == null || arr.length == 0) {
    return 0;
  }

  let max = 0;
  let cur = 0;
  for (let i = 0; i < arr.length; i++) {
    cur += arr[i];
    max = Math.max(max, cur); // 每轮都去最大的值
    // 抛弃为负数的值，1 和 -2 相加 则为 -1，结果为负数，抛弃它，重新设置为0，从3这里从新开始累加
    cur = cur < 0 ? 0 : cur;
  }
  return max;
}
```

## 求目标值在数组相加的位置

```javascript
// 求目标值在数组相加的位置
function twoSum(nums, target) {
  let arr = []
  for (let i = 0; i < nums.length; i++) {
    let temp = target - nums[i]
    if (arr[temp] !== undefined) {
      return [arr[temp], i]
    }
    arr[nums[i]] = i
  }
}

console.log(twoSum([1, 7, 7, 1, 10, 22, 2], 9))
```

## 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一

```javascript
/**
 * 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
 *
 * 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
 *
 * 你可以假设除了整数 0 之外，这个整数不会以零开头。
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function (digits) {
  let len = digits.length - 1
  while (len >= 0) {
    if (digits[len] + 1 < 10) {
      digits[len] = digits[len] + 1
      return digits
    } else {
      digits[len] = 0
    }
    len--
  }
  digits.unshift(1)
  digits[1] = 0
  return digits
};

console.log(plusOne([8, 9, 9, 9]))
```

## 二叉树的最小深度

```javascript
/**
 * leetcode 111. 二叉树的最小深度
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
  if (root == null) {
    return 0
  }
  let l = minDepth(root.left)
  let r = minDepth(root.right)
  if (root.left == null || root.right == null) {
    return l + r + 1
  }
  return Math.min(l, r) + 1
};

```

## 二叉树最大深度

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * 二叉树最大深度
 * @param {TreeNode} root
 * @return {number}
 */
// 递归
var maxDepth = function (root) {
  if (!root) {
    return 0;
  } else {
    let l = maxDepth(root.left);
    let r = maxDepth(root.right);
    return Math.max(l, r) + 1;
  }
};
```

