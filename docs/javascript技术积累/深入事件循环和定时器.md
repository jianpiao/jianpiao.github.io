## 浏览器的生命周期
浏览器输入url到渲染到过程需要经历很多的步骤，下图介绍了输入`https://www.ghzs.com/`时，生命周期从开始到结束到过程：

![生命周期流程](https://pic1.zhimg.com/80/v2-a331224c9fbdff4733456224fca790b8_720w.jpeg)

浏览器输入URL之后浏览器会解析URL -> 解析DNS，返回IP地址 -> 发起TCP请求，进行三次握手 -> 资源相应 -> 页面构建，包括DOM Tree节点生成，事件处理 -> 构建完毕，生命周期结束

## 页面构建阶段
这里我主要介绍一下页面构建阶段。

页面构建阶段的目标是建立Web应用的UI，其主要包括两个步骤:

1. 解析HTML代码并构建文档对象模型（DOM）；

2. 执行Javascript代码；

浏览器处理HTML节点的过程中会交替的执行上面的两个步骤，即构建DOM和脚本执行。

![构建阶段](https://pic1.zhimg.com/80/v2-9a7e731d7c0598b502252bf53b5442a1_720w.jpeg)

### 执行Javascript代码

所有包含在脚本中的js代码由浏览器的js引擎执行，例如，Firefox的Spidermonkey引擎， Chrome 和 Opera 的 V8引擎 和Edge的(IE的)Chakra引擎。由于代码的主要目的是提供动态页面， 故而浏览器通过全局对象提供了一个API 使JavaScript引擎可以与之交互 并改变页面内容。

js代码会有两种类型，区分两种类型的方式就是js代码所在的位置：

* 包括在函数内的叫做函数执行上文代码；
* 包括在脚本上下午(window)的叫做全局代码；

全局代码在执行到脚本的时候会从上往下一行一行的执行，函数的代码会在被全局代码调用的时候执行。

当浏览器在页面构建阶段遇到了脚本节点，它会停止HTML到DOM 的构建，转而开始执行JavaScript代码，也就是执行包含在脚本元素的全局JavaScript代码。

最后，当浏览器处理完所有HTML元素后，页面构建阶段就结束 了。随后浏览器就会进入应用生命周期的第二部分:事件处理。

## 事件处理

我们一般所说的web应用可以统称为GUI应用，也就是说这种应用会对不同类型 的事件作响应，如鼠标移动、单击和键盘按压等。因此，在页面构建阶 段执行的JavaScript代码，除了会影响全局应用状态和修改DOM外，还会注册事件监听器(或处理器)。这类监听器会在事件发生时，由浏览器调用执行。有了这些事件处理器，我们的应用也就有了交互能力。在详细探讨注册事件处理器之前，让我们先从头到尾看一遍事件处理器的总体 思想。

### 事件处理器概述

JavaScript的执行是单线程的，也就是说同一时刻只能执行一个代码片段，即所谓的单线程执行模型。

想象一下在天河公园排队相亲，很多人都看上了一个相亲对象，所以一窝蜂的单身汪排队。每个单身汪加入队伍等待叫号并“处理”。只有一个相亲对象和一堆单身汪进行交流，每当轮到某个单身汪时（某个事件），相亲对象只和一个单身汪进行交谈（处理）。

单身汪要做的就是安静的排队，等待被叫号，当一个事件抵达后，浏览器需要执行相应的事件处理函数。这里不保证每个单身汪总会极富耐心地 等待很长时间，直到下一个事件触发。所以浏览器需要一种方式跟踪发生但未处理的事件。为了实现这个目标，浏览器使用了事件队列。



![事件队列](https://pic1.zhimg.com/80/v2-78a586ce80053448d4892ecfb35e30f2_720w.jpeg)



所有已生成的事件(无论是用户生成的，例如鼠标移动或键盘按压，还是服务器生成的，例如Ajax，Fetch事件)都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。事件处理的过程可以描述为一个简单的流程图（如上图）。

* 浏览器检查事件队列头部的对首事件
* 如果浏览器没有队列对首，则继续检查
* 如果浏览器在队列对首中检查到了事件，则取出该事件并执行相应的事件处理器。在这个过程中，余下的事件在事件队列中耐心的等待，直到轮到它们被处理

重点注意浏览器在这个过程中的机制，其放置事件的队列是在页面构建阶段和事件处理阶段以外的。这个过程对于决定事件啥时候发生并将其推入事件队列很重要，这个过程不会参与事件处理线程。

> 提示：
>
> 由于一次只能处理一个事件，所以我们必须格外注意处理所有事件的总时间。执行需要花费大量时间执行的事件处理函数会导致应用卡屏、无响应、卡机等等!
>
> 如果js执行需要花费大量的时间可以考虑web work，参考[阮一峰的Web Worker 使用教程，http://www.ruanyifeng.com/blog/2018/07/web-worker.html](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)

### 异步事件

对于事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生。

* 浏览器事件，例如当页面加载完成后或无法加载时
* 网络事件，例如来自服务器的相应（Ajax事件、Fetch和服务器事件）
* 用户事件，例如鼠标单击‘鼠标移动和键盘事件
* 计时器事件，当timeout事件到了或者又触发了一次事件间隔

我们平时遇到的web场景中，大部分内容都是对上面事件的处理。

在事件能被处理之前，代码必须要告诉浏览器我们要处理特定事件了。接下来就看看如何注册事件处理器。

## 注册事件处理器

啥是事件处理器？又怎么注册呢？

前面已经讲过了，事件处理器是当某个特定事件发生后我们希望执行的函数。为了达到这个目标，我们必须告知浏览器我们要处理哪个事件。这个过程叫作注册事件处理器。在咱们常见的Web应用中，有两种方式注册事件。

* 函数调用，把函数赋值给某个属性或者IIFE（立即执行函数）
* 事件监听，比如addEventListener



举个例子说明一下函数调用。将一个函数赋值给window的onload属性：

```javascript
window.onload = function(){
  // do something
}
```

通过上面的方式，事件处理器就会注册到onload事件上。



举例例子说明一下事件监听。上面的方式很容易在日常开发的时候被不知情的小伙伴重写、覆盖。可以使用`addEventListener`来实现：

```javascript
document.body.addEventListener("mousemove", function() {
  // do something
})
```

通过上面的方式，为`mousemove`事件注册处理器。

### 处理事件

我总结的事件处理背后的主要思想是：当事件发生时，浏览器调用相应的事件处理器。

由于浏览器是单线程执行模型，所以同一时刻只能处理一个事件。任何后面的事件都只能在当前事件完全结束后才能被处理。



![事件处理](https://pic4.zhimg.com/80/v2-658c0e3373425ebbd10fe66dba64d932_720w.jpeg)



我们以上面图片的例子来讲解一下事件处理。浏览器为了响应用户的动作，把鼠标移动和单击事件以它们发生的次序放入事件队列：第一个是鼠标移动事件，第二个单击事件。

在事件处理阶段中，事件循环会检查队列，发现队列的前面有一个鼠标移动事件，然后执行了相应的事件处理（序号2）。当鼠标移动事件处理器处理完毕后，轮到了等待在队列中的单击事件。当鼠标移动事件处理球函数的最后一行代码执行完毕后，JavaScript引擎退出事件处理函数，鼠标移动事件就处理完成了（序号3）。事件循环再次检查队列，发现鼠标单击事件并对该事件进行处理。一旦单击事件执行完毕，任务队列中（宏任务）没有信的事件，事件循环会继续循环，等待新的事件到来。这个循环会一直执行，直到用户关闭了应用（结束了当前脚本的全局执行上下文）。

这里我们讲到了事件循环，下面就深入事件循环，探寻更广的视野！

## 跨平台开发能力

这里为什么我要先讲解一下跨平台能力，是因为JavaScript以及不至于浏览器这个执行环境了，还有Node.js。

两种执行环境提供的API会有一些差异，其中就包括后面要讲解的事件循环、异步、定时器。通过下图简单的了解一下两个执行环境的差异。

![执行环境的差异](https://pic4.zhimg.com/80/v2-6a1a2f6e26a6330b9c0683cfbeec1b4e_720w.jpeg)

下面会先讲解浏览器的事件循环、事件处理。



## 深入事件循环

事件循环包含至少两个队列，除了事件队列，还有浏览器执行的其他操作任务的队列，这些操作任务分类两类，宏任务和为微任务。

属于宏任务事件有如下：

- setTimeout
- setInterval
- setImmediate
- MessageChannel
- requestAnimationFrame
- I/O
- UI交互事件



属于微任务事件有如下：

- Promise.then
- MutationObserver
- Object.observe
- Process.nextTick



在浏览器环境中，宏任务多例子，包括创建文档对象（DOM）、解析HTML、执行主线层JavaScript代码，页面加载、表单标签输入、网络事件、定时器等等。从浏览器等角度来看，宏任务像是一个离散的、独立的工作单元。执行完毕任务后，浏览器可以继续其他事件调度，如重新渲染页面的UI或者进行垃圾回收。

而微任务是更小的任务。微任务更新应用程序的状态（Promise），但必须要在浏览器任务（宏任务）继续执行其他任务之前执行。浏览器任务包括重新渲染页面的UI。微任务的例子包括promise回调函数、DOM节点发生变化等等。微任务要尽快的执行，通过异步的方式执行。微任务可以在重新渲染UI之前执行指定的行为，比如请求接口等等，避免不必要的UI重绘，UI重绘频率低的情况会产生视觉上的掉帧，每一帧低于16.6ms肉眼就能直观感受得到卡了。

事件循环会有两个任务队列，一个是宏任务，一个是微任务。两个队列在同一时刻只执行一个任务事件。看下图：

![任务队列](https://pic4.zhimg.com/80/v2-8b2fd4e821bc391e518353e05f827909_720w.jpeg)

事件循环给予两个基本原则：

1. 一次处理一个任务
2. 一个任务开始后直到任务完成，不会被其他任务打断



事件循环首先会检查宏任务队列，如果宏任务等待，则开始执行宏任务，直到该任务执行完毕。如果宏任务队列为空，事件循环会开始检查微任务队列。微任务队列有任务则事件循环将依次执行，直到所有的微任务都执行完毕。

这里我们要注意一下哈，一轮事件循环中，只执行一个宏任务，其余的在队列中等待，而微任务则全部执行。

当微任务队列处理完毕并清空时，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI试图。到这里为止，一轮事件循环已经结束了。事件循环又会开始检查宏任务队列，这个时候也是重新开启了一轮新的事件循环。



### 细节

通过上面对事件循环应该有了全面的了解，有一些小细节要再深入一下。

* 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外。如果不这样设计，则会导致在执行 JavaScript代码时，发生的任何事件都将被忽略。正因为我们不希望看到这种情况，因此检测和添加任务的行为，是独立于事件循环完成的。你可以理解为当JavaScript执行环境上下午的时候把事件丢进了宏任务队列或者微任务队列，它跟事件循环是没啥交互的。

* 因为JavaScript基于单线程执行模型，所以这两类任务都是逐个执行的。当一个任务开始执行后，在完成前，中间不会被任何其他任务中断。除非浏览器决定中止执行该任务，例如，某个任务执行时间过长或内存占用过大。
* 所有微任务会在下一次渲染之前执行完成，因为它们的目标是在渲染前更新应用程序状态。
* 浏览器通常会尝试每秒渲染60次页面，以达到每秒60帧(60 fps) 的速度。60fps通常是检验体验是否平滑流畅的标准，比方在动画里，这意味着浏览器会尝试在16ms内渲染一帧。就上面的图片所示的“更新渲染”是如何发生在事件循环内的？因为在页面渲染 时，任何任务都无法再进行修改。 这些设计和原则都意味着，如果想要实现平滑流畅的应用，我们是没有太多时间浪费在处理单个事件循环任务的。理想情况下，单个任务和该任务附属的所有微任务，都应在16ms内完成。



### 宏任务和微任务的例子

先写个代码，让它包含宏任务和微任务

```html
<button id="firstButton"></button>
<button id="secondButton"></button>
<script>
  const firstButton = document.getElementById("firstButton");
  const secondButton = document.getElementById("secondButton");   
  firstButton.addEventListener("click", function firstHandler(){    
    Promise.resolve().then(() => {
    	/* promise代码执行 4 ms*/   
    }); // 立即对象promise，并且执行then方法中的回调函数    
    /* 点击事件监听器代码执行 8 ms*/
 	});
 	secondButton.addEventListener("click", function secondHandler(){    
   /* 点击事件监听器代码执行 5ms*/
 	});
  
	/* 代码执行 15ms*/
</script>
```

上面的例子中，假设发生一下行为：

* 第5ms单击firstButton。
*  第12ms单击secondButton。
*  firstButton的单击事件处理函数firstHandler需要执行8ms。
*  secondButton的单击事件处理函数secondHandler需要执行5ms。

在firstHandler代码中我们创建立即兑现的promise，并需要运行4ms的传入回调函数。因为promise表示当前未知的一个未来值，因此promise处理函数总是异步执行。

我们创建立即兑现的promise。说实话，JavaScript引擎 本应立即调用回调函数，因为我们已知promise成功兑现。但是，为了 连续性，JavaScript引擎不会这么做，仍然会在firstHandler代码执行(需 要运行8ms)完成之后再异步调用回调函数。通过创建微任务，将回调 放入微任务队列。让我们看看本例执行的时间轴，看下面图所示：

![微任务和宏任务](https://pic2.zhimg.com/80/v2-e4842fb8bef72ca8d995a9b7c52f62af_720w.jpeg)

> 注意：为了方便观看，省略了UI渲染阶段。

如果微任务队列中含有微任务，不论队列中等待的其他任务，微任务都将获得优先执 行权。在本例中，promise微任务优先于secondButton单击任务开始执行。在微任务处理完成之后，当且仅当微任务队列中没有正在等待中的微任务，才可以重新渲染页面。在我们的示例中，当promise处理器运 行结束，在第二个按钮单击处理器执行之前，浏览器可以重新渲染页面。

注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，所有微任务的优先权高于secondButton单击任务。只有当微任务队列为空时，事件循环才会开始重新渲染页面，继续执行secondButton单 击任务，需要注意!

现在已经了解了事件循环的工作机制了，接下来开始讲解一下下一种特殊类型的事件：计时器。

## 计时器：setTimeout和setInterval

由上面的事件循环我们知道计时器是属于宏任务队列的。

浏览器提供两种创建计时器的方法，分别是`setTimeout`和`setInterval`。浏览器还提供两个清除计时器的方法，分别是：`clearTimeout`和`clearInterval`。这些方法都是挂载在window对象（全局上下午）的方法。与事件循环类型不同的是，计时器是由宿主环境提供的，比如浏览器环境和Node.js环境。

之所以要讲计时器，是想要让我们理解，计时器的延迟时间是无法确保的，理解这一点非常重要。

### 在事件循环中执行计时器

咱们举个例子，在事件循环中执行个计时器，看下面代码：

```html
<button id="myButton"></button>
<script>
  setTimeout(function timeoutHandler(){
   /* 计时器代码执行 6ms*/   
  }, 10);  // 注册10ms后延迟执行函数
  
  setInterval(function intervalHandler(){
   /* 计时器代码执行 8ms*/   
  }, 10); // 注册每10ms执行的周期函数
  
  const myButton = document.getElementById("myButton");
  
  myButton.addEventListener("click", function clickHandler(){    
    /* 点击事件执行 10ms*/
  });  // 为按钮单击事件注册事件处理器
  
  /* 代码执行 18ms*/ 
</script>
```

上面的例子只有一个按钮，但是注册了两个计时器，首先注册延迟执行计时器，延迟10ms。

延迟执行回调函数需要执行6ms。接着，我们也注册了一个间隔执 行计时器，每隔10ms执行一次。

间隔执行回调函数需要执行8ms。我们继续注册一个单击事件处理器，需要执行10ms。

本例中的同步代码块需要运行18ms（脑补一些复杂的代码）。

![计时器](https://pic1.zhimg.com/80/v2-ee669bd0d1448ac9dfd2717253703c0c_720w.jpeg)

上图显示程序前18ms的执行状态。起初，当前运行中的任务是执行主线程JavaScript 代码。执行主线程代码需要耗时18ms。在执行主线程代码时，发生3个事件:鼠标单击事件、 延迟计时器到期事件和间隔计时器触发事件。

执行过程：

1. 在0ms时，延迟计时器延迟10ms执行，间隔计时器也是间隔 10ms。计时器的引用保存在浏览器中。
2. 在6ms时，单击鼠标。
3. 在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。
4. 18ms页面渲染结束。

在第18ms初始化代码结束执行时，3个代码片段正在等待执行:单击事件处理器、延迟计时处理器和间隔计时处理器。这意味着单击事件处理器开始执行。

咱们来看看下面的图：

![计时器](https://pic1.zhimg.com/80/v2-5238ec4e3158997454c8f66a6956316a_720w.jpeg)

setTimeout函数只到期一次，setInterval函数则不同，setInterval会持 续执行直到被清除。因此，在第20ms时，setInterval又一次触发。但是，此时间隔计时器的实例已经在队列中等待执行，该触发被中止。浏览器不会同时创建两个相同的间隔计时器。

还记得代码中的`setTimeout`吗，设定的是10ms后执行，但是看上面的图片，在第28ms才执行。

这就是为什么我们需要特别小心，计时器提供一种异步延迟执行代 码片段的能力，至少要延迟指定的毫秒数。因为JavaScript单线程的本 质，我们只能控制计时器何时被加入队列中，而无法控制何时执行。现 在，我们解开谜题了，让我们继续应用程序的剩余部分。

延迟计时处理器需要执行6ms，将会在第34ms时结束执行。在这段 时间内，第30ms时另一个间隔计时器到期。这一次仍然不会添加新的间 隔计时器到队列中，因为队列中已经有一个与之相匹配的间隔计时器。 在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页 面的机会，然后进入下一个事件循环迭代。

最后，间隔计时处理器在第34ms时开始执行，此时距离添加到队列 相差24ms。又一次强调传入setTimeout(fn, delay)和setInterval(fn, delay) 的参数，仅仅指定计时器添加到队列中的时间，而不是准确的执行时 间。

间隔计时处理器需要执行8ms，当它执行时，另一个间隔计时器在 40ms时到期。此时，由于间隔处理器正在执行(不是在队列中等待)， 一个新的间隔计时任务添加到任务队列中，应用程序继续执行，如下面图所示。设置间隔时间10ms并不意味着每10ms处理器就会执行完 成。由于任务在队列中等待，每一个任务的执行时间有可能不同，一个 接一个地依次执行，如本例的第42ms和第50ms时。

![计时器5](https://pic4.zhimg.com/80/v2-99ef8b05dacee1dff14f4cf61e02ae69_720w.jpeg)

上图在间隔处理器开始按每10ms执行之前，由单击处理和延迟执行引起的周折，需要花费一些时间。

最终，50ms之后，时间间隔稳定在每10ms执行一次。

通过上面的案例，我们需要记住一个重要的概念是事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确切时间。间隔处理程序尤其如此。 在这个例子中我们看到，尽管我们预定间隔在10、20、30、40、50、60 和70ms时触发，回调函数却在34、42、50、60和70ms时执行。在本例 中，少执行了两次回调函数，有几次回调函数没有在预期的时间点执 行。可以看出，时间间隔需要特殊考虑，并不适用于延迟执行。让我们看得更仔细些。

### 延迟执行与间隔执行的区别

`setTimeout()` 内的代码在前一个回调函数执行完成之后，至少延迟10ms执行(取决于事件队列的状态，等待时间只会大于10ms);而`setInterval()`会尝试每 10ms执行回调函数，不关心前一个回调函数是否执行。

## Node.js 事件循环、定时器

上面说的是浏览器环境下的事件循环和定时器，接下来讲讲基于Node.js环境下的事件循环和定时器。

事件循环是Node.js处理非堵塞I/O操作的机制，尽管JavaScript是单线程处理的，当有可能的时候，他们会把操作转移到系统内核中去。

既然目前大多数内核都是多线程的，它们可以在后台处理多种操作。当使用的一个操作完成的时候，内核通知Node.js将合适的回调函数添加到轮询队列中等待时机执行。后面会讲到这一块。

### Node.js事件循环机制解析

当Node.js启动后，它会初始化事件循环，处理已提供的输入脚本它可能会调用一些异步的 API、调度定时器，或者调用 `process.nextTick()`，然后开始处理事件循环。

面的图表展示了事件循环操作顺序的简化概览。

```basic
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

> 注意：每一个框框被称为事件循环的一个阶段。

每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段，等等。

由于这些操作中的任何一个都可能调度更多的操作和由内核排列在轮询阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。



### 六个阶段

- **定时器**：本阶段执行已经被 `setTimeout()` 和 `setInterval()` 的调度回调函数。
- **待定回调**：执行延迟到下一个循环迭代的 I/O 回调。
- **idle, prepare**：仅系统内部使用。
- **轮询**：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 `setImmediate()` 调度的之外），其余情况 node 将在适当的时候在此阻塞。
- **检测**：`setImmediate()` 回调函数在这里执行。
- **关闭的回调函数**：一些关闭的回调函数，如：`socket.on('close', ...)`。

在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。

### 阶段详细概述

#### 计时器

计时器指定可以执行所提供回调的阀值，而不是用户希望执行的确切时间。在指定的一段时间间隔后，计时器回调将被尽可能的运行。但是，操作系统调度或其他正在运行的回调可能会延迟它们。

有一点需要注意的，轮询阶段，控制什么时候计时器执行。

例如，假设调度了一个在 100 ms后超时的定时器，然后脚本开始异步读取会耗费 95 ms的文件:

```javascript
const fs = require('fs');

function someAsyncOperation(callback) {
  // 这里花费95ms完成
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms 后被执行`);
}, 100);

// 异步操作花费了95ms完成
someAsyncOperation(() => {
  const startCallback = Date.now();

  // 这里将花费10m
  while (Date.now() - startCallback < 10) {
    // do nothing
  }
});
```

当事件循环进入轮训阶段时，它有一个空队列（此时fs.readfile()尚未完成），因此它将等待剩下的毫秒数，直到达到最快的一个计时器阀值为止。当它等待95毫秒过后时，`fs.readFile()`完成读取文件，它的那个需要10ms才能完成的回调，将被添加到轮询队列中并执行。当回调完成时，队列中不再有回调，因此事件循环机制将检查最快到达阀值当计时器，然后将回到计时器阶段，以执行定时器的回调。在本示例中，你将看到调度计时器到它的回调被执行之间的总延迟将为 105 毫秒。

这里有个需要注意的点：为了防止轮训阶段弄死事件循环，libuv（实现 Node.js 事件循环和平台的所有异步行为的 C 函数库），在停止轮询以获得更多事件之前，还有一个硬性最大值，当然这个具体是依赖于系统的。

#### 挂载阶段回调函数

此阶段对某些系统操作（如TCP错误类型）执行回调。例如，如果TCP套接字在尝试链接时接收到`ECONNREFUSED`，则某些 `*nix` 的系统希望等待报告错误。这将被排队以在挂起的回调阶段执行。

#### 轮询

轮询阶段有两个重要的功能：

1. 计算机阻塞和轮询I/O的时间
2. 然后，处理轮询队列里的事件

当事件循环进入轮询阶段且没有被调度的计时器时，将会一下两种情况之一：

* 如果轮询队列不为空的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。
* 如果轮询队列为空的，还说有两件事发生：
  * 如果脚本被`setImmediate()`调度，则事件循环将结束轮询阶段，并继续检查阶段以执行那些被调度的脚本。
  * 如果脚本未被`setImmediate()`调度，则事件循环将等待回调被添加到队列中，然后立即执行。

一旦轮询队列为空，事件循环将检查以达到时间阀值的计时器。如果一个或者多个计时器已经准备就绪，则事件循环将绕回计时器阶段执行这些计时器的回调。

#### 检查阶段

此阶段允许人员在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用 `setImmediate()` 后被排列在队列中，则事件循环可能继续到检查阶段而不是等待。

`setImmediate()` 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在轮询 阶段完成后执行。

通常，在执行代码时，事件循环最终会命中轮询阶段，在那等待传入连接、请求等。但是，如果回调已使用 `setImmediate()`调度过，并且轮询阶段变为空闲状态，则它将结束此阶段，并继续到检查阶段而不是继续等待轮询事件。

#### 关闭的回调函数

如果套接字或处理函数突然关闭（例如 `socket.destroy()`），则`'close'` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。

### `setImmediate()`对比`setTimeout()`

`setImmediate()` 和 `setTimeout()` 很类似，但是基于被调用的时机，他们也有不同表现。

- `setImmediate()` 设计为一旦在当前轮询阶段完成， 就执行脚本。
- `setTimeout()` 在最小阈值（ms 单位）过后运行脚本。

执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时器将受进程性能的约束（这可能会受到计算机上其他正在运行应用程序的影响）。

例如，如果运行以下不在 I/O 周期（即主模块）内的脚本，则执行两个计时器的顺序是非确定性的，因为它受进程性能的约束：

```javascript
// timeout_vs_immediate.js
setTimeout(() => {
  console.log('timeout');
}, 0);

setImmediate(() => {
  console.log('immediate');
});
```

> 上面是代码
>
> 下面是打印

```basic
$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout
```

但是，如果你把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用：

```javascript
// timeout_vs_immediate.js
const fs = require('fs');

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log('timeout');
  }, 0);
  setImmediate(() => {
    console.log('immediate');
  });
});
```

> 上面的代码
>
> 下面是打印

```basic
$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout
```

使用 `setImmediate()` 相对于`setTimeout()` 的主要优势是，如果`setImmediate()`是在 I/O 周期内被调度的，那它将会在其中任何的定时器之前执行，跟这里存在多少个定时器无关。

### `process.nextTick()`

你可能已经注意到 `process.nextTick()` 在图示中没有显示，即使它是异步 API 的一部分。这是因为 `process.nextTick()` 从技术上讲不是事件循环的一部分。相反，它都将在当前操作完成后处理 `nextTickQueue`， 而不管事件循环的当前阶段如何。这里的一个操作被视作为一个从底层 C/C++ 处理器开始过渡，并且处理需要执行的 JavaScript 代码。

可以回顾一下一开始的阶段图，任何时候在给定的阶段中调用 `process.nextTick()`，所有传递到 `process.nextTick()` 的回调将在事件循环继续之前解析。这可能会造成一些糟糕的情况，因为它允许你通过递归`process.nextTick()`调用来“搞死”你的I/O，阻止事件循环到达轮询阶段。

**为什么会允许这样**

为什么这样的事情会包含在 Node.js 中？它的一部分是一个设计理念，其中 API 应该始终是异步的，即使它不必是。以此代码段为例：

```javascript
function apiCall(arg, callback) {
  if (typeof arg !== 'string'){
    return process.nextTick(callback, new TypeError('argument should be string'));
  }
}
```

代码段进行参数检查。如果不正确，则会将错误传递给回调函数。最近对 API 进行了更新，允许传递参数给 `process.nextTick()`，这将允许它接受任何在回调函数位置之后的参数，并将参数传递给回调函数作为回调函数的参数，这样就不必嵌套函数了。

我们正在做的是将错误传回给用户，但仅在执行用户的其余代码之后。通过使用`process.nextTick()`，我们保证 `apiCall()` 始终在用户代码的其余部分*之后*和在让事件循环继续进行之前，执行其回调函数。为了实现这一点，JS 调用栈被允许展开，然后立即执行提供的回调，允许进行递归调用 `process.nextTick()`，而不触碰 `RangeError: 超过 V8 的最大调用堆栈大小` 限制。

这种设计原理可能会导致一些潜在的问题。 以此代码段为例：

```javascript
let bar;

// 它具有异步签名，但以同步方式调用回调
function someAsyncApiCall(callback) { callback(); }

// 回调函数在someAsyncApiCall完成之前被调用
someAsyncApiCall(() => {
  // someAsyncApiCall已经完成后，bar不会分配任何值
  console.log('bar', bar); // undefined
});

bar = 1;
```

用户将 `someAsyncApiCall()` 定义为具有异步签名，但实际上它是同步运行的。当调用它时，提供给 `someAsyncApiCall()` 的回调是在事件循环的同一阶段内被调用，因为 `someAsyncApiCall()` 实际上并没有异步执行任何事情。结果，回调函数在尝试引用 `bar`，但作用域中可能还没有该变量，因为脚本尚未运行完成。

通过将回调置于 `process.nextTick()` 中，脚本仍具有运行完成的能力，允许在调用回调之前初始化所有的变量、函数等。它还具有不让事件循环继续的优点，适用于让事件循环继续之前，警告用户发生错误的情况。下面是上一个使用 `process.nextTick()` 的示例：

```javascript
let bar;

function someAsyncApiCall(callback) {
  process.nextTick(callback);
}

someAsyncApiCall(() => {
  console.log('bar', bar); // 1
});

bar = 1;
```

这又是另外一个真实的例子：

```js
const server = net.createServer(() => {}).listen(8080);

server.on('listening', () => {});
```

只有传递端口时，端口才会立即被绑定。因此，可以立即调用 `'listening'` 回调。问题是 `.on('listening')` 的回调在那个时间点尚未被设置。

为了绕过这个问题，`'listening'` 事件被排在 `nextTick()` 中，以允许脚本运行完成。这让用户设置所想设置的任何事件处理器。

这里给语言开发者一个大大的nice拇指！！！

### `process.nextTick()` 对比 `setImmediate()`

这样要纠正一下对于这两个的理解，因为按照字面意思来说，它们两个的实际作用和字面意思是完全相反的。这个是一个很令人头疼和费解的东西。

- `process.nextTick()` 在同一个阶段立即执行。
- `setImmediate()` 在事件循环的接下来的迭代或 'tick' 上触发。

实质上，这两个名称应该交换，因为 `process.nextTick()` 比 `setImmediate()` 触发得更快，但这是过去遗留问题，因此不太可能改变。如果贸然进行名称交换，将破坏 npm 上的大部分软件包。每天都有更多新的模块在增加，这意味着我们要多等待每一天，则更多潜在破坏会发生。尽管这些名称使人感到困惑，但它们本身名字不会改变。

我们建议大伙们（开发人员）在所有情况下都使用 `setImmediate()`，因为它更容易理解。

### 为什么要使用 `process.nextTick()`?

上面是建议来使用`setImmediate()`，但是有一些常见是可以使用`process.nextTick()`的。

有两个主要原因：

1. 允许用户处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。
2. 有时有让回调在栈展开后，但在事件循环继续之前运行的必要。

下面举一个符合用户预期的简单示例：

```javascript
const server = net.createServer();
server.on('connection', (conn) => { });

server.listen(8080);
server.on('listening', () => { });
```

假设 `listen()` 在事件循环开始时运行，但 listening 的回调被放置在 `setImmediate()`中。除非传递过主机名，才会立即绑定到端口。为使事件循环继续进行，它必须命中轮询阶段，这意味着有可能已经接收了一个连接，并在侦听事件之前触发了连接事件。

另一个示例运行的函数构造函数是从 `EventEmitter` 继承的，它想调用构造函数：

```javascript
const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);
  this.emit('event');
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
```

你不能立即从构造函数中触发事件，因为脚本尚未处理到用户为该事件分配回调函数的地方。因此，在构造函数本身中可以使用 `process.nextTick()` 来设置回调，以便在构造函数完成后发出该事件，这是预期的结果：

```javascript
onst EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);

  // use nextTick to emit the event once a handler is assigned
  process.nextTick(() => {
    this.emit('event');
  });
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
```

## 小结

* 通过介绍浏览器的生命周期切入，了解页面构建的过程中，脚本事件的工作流程。事件就处理是指当浏览器调用了相应的事件处理器。可以通过属性赋值和`addEventListener`的方式注册事件处理器。
* 通过事件循环详细的介绍了宏任务、微任务和UI渲染的工作流程。事件循环会先从宏任务队列中执行一个任务，执行完毕后会移动到微任务队列中执行完所有的微任务，执行完毕后会重新渲染UI。/
* 介绍了计时器`setTimeout()`和`setInterval()`的执行阶段以及实际使用的区别。`setTimeout()`会在前一个回调执行完毕之后执行，具体什么时候执行`setTimeout()`，取决于事件队列的状态以及前面回调执行的时长，通常情况都不会准时执行的;而`setInterval()`会尝试每 10ms（假设设置的是10ms）执行回调函数，不关心前一个回调函数是否执行。
* 了解了事件循环是Node.js处理非堵塞I/O操作的机制。Node.js的事件循环有六个阶段，每个阶段做的事情有所不同。
* `setImmediate()`和`setTimeout()`的执行顺序是不定性的。但是，如果你把这两个函数放入一个 I/O 循环内调用，`setImmediate()` 总是被优先调用：
* `process.nextTick()` 和 `setImmediate()`的实际作用与字面意思是相反的。一般情况，推荐使用`setImmediate()`，因为它更容易理解。



### 参考文献

1. 《深入理解Node.js》，作者: [朴灵](https://book.douban.com/search/朴灵) 
2. JavaScript忍者秘籍（第2版），作者: [[美\] John Resig（莱西格）](https://book.douban.com/search/John Resig) / [[美\] Bear Bibeault（贝比奥特）](https://book.douban.com/search/Bear Bibeault) / [[美\] Josip Maras（马瑞斯）](https://book.douban.com/search/Josip Maras) 
3. Node.js官网文档，https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/

