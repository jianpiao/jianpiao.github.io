<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>了解HTTP | smallzip‘s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="smallzip 个人博客">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.066415a4.js" as="script"><link rel="preload" href="/assets/js/2.88013ddf.js" as="script"><link rel="preload" href="/assets/js/38.42798cb0.js" as="script"><link rel="prefetch" href="/assets/js/10.a4ef063b.js"><link rel="prefetch" href="/assets/js/11.e0b429a7.js"><link rel="prefetch" href="/assets/js/12.e20c3821.js"><link rel="prefetch" href="/assets/js/13.69446fa5.js"><link rel="prefetch" href="/assets/js/14.40a69240.js"><link rel="prefetch" href="/assets/js/15.d79e25ed.js"><link rel="prefetch" href="/assets/js/16.deaa757e.js"><link rel="prefetch" href="/assets/js/17.f3b78599.js"><link rel="prefetch" href="/assets/js/18.e0cbb34d.js"><link rel="prefetch" href="/assets/js/19.a384534b.js"><link rel="prefetch" href="/assets/js/20.25819ed0.js"><link rel="prefetch" href="/assets/js/21.9b25e7d8.js"><link rel="prefetch" href="/assets/js/22.79660f12.js"><link rel="prefetch" href="/assets/js/23.26c447c6.js"><link rel="prefetch" href="/assets/js/24.98cd7c98.js"><link rel="prefetch" href="/assets/js/25.441a1ca7.js"><link rel="prefetch" href="/assets/js/26.84031911.js"><link rel="prefetch" href="/assets/js/27.bafff794.js"><link rel="prefetch" href="/assets/js/28.17ae604e.js"><link rel="prefetch" href="/assets/js/29.9adf9e6e.js"><link rel="prefetch" href="/assets/js/3.90cc8f9a.js"><link rel="prefetch" href="/assets/js/30.2df852a8.js"><link rel="prefetch" href="/assets/js/31.526aab82.js"><link rel="prefetch" href="/assets/js/32.3278c180.js"><link rel="prefetch" href="/assets/js/33.a479dab2.js"><link rel="prefetch" href="/assets/js/34.c66ebf16.js"><link rel="prefetch" href="/assets/js/35.1be688a1.js"><link rel="prefetch" href="/assets/js/36.657725d7.js"><link rel="prefetch" href="/assets/js/37.44422a55.js"><link rel="prefetch" href="/assets/js/39.061887e0.js"><link rel="prefetch" href="/assets/js/4.38c737a7.js"><link rel="prefetch" href="/assets/js/40.b251b075.js"><link rel="prefetch" href="/assets/js/41.6ac7a71f.js"><link rel="prefetch" href="/assets/js/42.edd207fd.js"><link rel="prefetch" href="/assets/js/43.fea48edc.js"><link rel="prefetch" href="/assets/js/44.b2383325.js"><link rel="prefetch" href="/assets/js/5.004cb1ad.js"><link rel="prefetch" href="/assets/js/6.9659a5eb.js"><link rel="prefetch" href="/assets/js/7.b893e3d8.js"><link rel="prefetch" href="/assets/js/8.59645141.js"><link rel="prefetch" href="/assets/js/9.985e472d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">smallzip‘s Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/e0d0e6cb34d2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.im/user/5a68b1945188256922633d02" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/jianpiao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/e0d0e6cb34d2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.im/user/5a68b1945188256922633d02" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/jianpiao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/《javascript高级程序设计》笔记.html" class="sidebar-link">《javascript高级程序设计》笔记</a></li><li><a href="/javascript技术积累.html" class="sidebar-link">javascript技术积累</a></li><li><a href="/linux笔记.html" class="sidebar-link">linux笔记</a></li><li><a href="/linux课堂代码案例.html" class="sidebar-link">linux课堂代码案例</a></li><li><a href="/算法学习笔记.html" class="sidebar-link">算法学习笔记</a></li><li><a href="/js数据结构与算法.html" class="sidebar-link">js数据结构与算法</a></li><li><a href="/javascript设计模式.html" class="sidebar-link">javascript设计模式</a></li><li><a href="/了解HTTP.html" class="active sidebar-link">了解HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/了解HTTP.html#了解web以及网络基础" class="sidebar-link">了解web以及网络基础</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#简单的http协议" class="sidebar-link">简单的HTTP协议</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#http报文内的http信息" class="sidebar-link">HTTP报文内的HTTP信息</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#返回结果的-http-状态-码" class="sidebar-link">返回结果的 HTTP 状态 码</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#与http协作的web服-务器" class="sidebar-link">与HTTP协作的Web服 务器</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#http首部" class="sidebar-link">HTTP首部</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#确保web安全的-https" class="sidebar-link">确保Web安全的 HTTPS</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#确认访问用户身份的认-证" class="sidebar-link">确认访问用户身份的认 证</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#ajax和websocket" class="sidebar-link">ajax和websocket</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#期盼已久的-http-2-0" class="sidebar-link">期盼已久的 HTTP/2.0</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#了解http0-9-http3" class="sidebar-link">了解HTTP0.9~HTTP3</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#媒体类型-mime" class="sidebar-link">媒体类型（MIME）</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#udp协议" class="sidebar-link">UDP协议</a></li><li class="sidebar-sub-header"><a href="/了解HTTP.html#tcp" class="sidebar-link">TCP</a></li></ul></li><li><a href="/Flutter学习笔记.html" class="sidebar-link">Flutter学习笔记</a></li><li><a href="/css学习笔记.html" class="sidebar-link">css学习笔记</a></li><li><a href="/Vue.html" class="sidebar-link">Vue</a></li><li><a href="/React.html" class="sidebar-link">React记录</a></li><li><a href="/React-Native.html" class="sidebar-link">React-Native记录</a></li><li><a href="/小程序记录.html" class="sidebar-link">小程序笔记</a></li><li><a href="/Git学习.html" class="sidebar-link">Git</a></li><li><a href="/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/js正则积累.html" class="sidebar-link">js正则积累</a></li><li><a href="/前端题目练习.html" class="sidebar-link">前端题目练习</a></li><li><a href="/服务器端积累.html" class="sidebar-link">服务器端积累</a></li><li><a href="/计算机基础.html" class="sidebar-link">计算机基础</a></li><li><a href="/网络基础知识.html" class="sidebar-link">网络基础</a></li><li><a href="/基础面试要点知识.html" class="sidebar-link">基础面试知识积累</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="了解http"><a href="#了解http" class="header-anchor">#</a> 了解HTTP</h1> <p>学习内容全部来自《图解HTTP》。</p> <h2 id="了解web以及网络基础"><a href="#了解web以及网络基础" class="header-anchor">#</a> 了解web以及网络基础</h2> <h3 id="使用-http-协议访问-web"><a href="#使用-http-协议访问-web" class="header-anchor">#</a> 使用 <strong>HTTP</strong> 协议访问 <strong>Web</strong></h3> <p>你知道当我们在网页浏览器(Web browser)的地址栏中输入 URL时，Web 页面是如何呈现的吗?</p> <p><img src="https://pic2.zhimg.com/80/v2-333c42f467d96b76138427ba5756a976_1440w.png" alt=""></p> <p>Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL，Web 浏览器从 Web 服务器端获取文件资源(resource)等信 息，从而显示出 Web 页面。</p> <p><img src="https://pic3.zhimg.com/80/v2-e31127a2c02b9d92bc34565bb0b9cb80_1440w.png" alt=""></p> <p>Web 使用一种名为 HTTP(HyperText Transfer Protocol，超文本传输协</p> <p>议 1)的协议作为规范，完成从客户端到服务器端等一系列运作流 程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通 信的。</p> <h3 id="http-的诞生"><a href="#http-的诞生" class="header-anchor">#</a> <strong>HTTP</strong> 的诞生</h3> <p>在深入学习 HTTP 之前，我们先来介绍一下 HTTP 诞生的背景。了解 背景的同时也能了解当初制定 HTTP 的初衷，这样有助于我们更好地 理解。</p> <h4 id="为知识共享而规划-web"><a href="#为知识共享而规划-web" class="header-anchor">#</a> 为知识共享而规划 Web</h4> <p>1989 年 3 月，互联网还只属于少数人。在这一互联网的黎明期，HTTP 诞生了。</p> <p><img src="https://pic2.zhimg.com/80/v2-d5110299fd22098c6b463bf0b96553cf_1440w.png" alt=""></p> <p>CERN(欧洲核子研究组织)的蒂姆 • 伯纳斯 - 李(Tim BernersLee) 博士提出了一种能让远隔两地的研究者们共享知识的设想。</p> <p>最初设想的基本理念是:借助多文档之间相互关联形成的超文本 (HyperText)，连成可相互参阅的 WWW(World Wide Web，万维 网)。</p> <p>现在已提出了 3 项 WWW 构建技术，分别是:把 SGML(Standard Generalized Markup Language，标准通用标记语言)作为页面的文本标 记语言的 HTML(HyperText Markup Language，超文本标记语言); 作为文档传递协议的 HTTP ;指定文档所在地址的 URL(UniformResource Locator，统一资源定位符)。</p> <p>WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。</p> <h4 id="驻足不前的-http"><a href="#驻足不前的-http" class="header-anchor">#</a> 驻足不前的  HTTP</h4> <p><strong>HTTP/0.9</strong></p> <p>HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。 现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为 HTTP/0.9。</p> <p><strong>HTTP/1.0</strong></p> <p>HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP/1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今 仍被广泛使用在服务器端。</p> <p><strong>HTTP/1.1</strong></p> <p>1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的 标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版 本。</p> <p>可见，作为 Web 文档传输协议的 HTTP，它的版本几乎没有更新。新 一代 HTTP/2.0 正在制订中，但要达到较高的使用覆盖率，仍需假以 时日。</p> <p>当年 HTTP 协议的出现主要是为了解决文本传输的难题。由于协议本 身非常简单，于是在此基础上设想了很多应用方法并投入了实际使 用。现在 HTTP 协议已经超出了 Web 这个框架的局限，被运用到了 各种场景里。</p> <h3 id="网络基础-tcp-ip"><a href="#网络基础-tcp-ip" class="header-anchor">#</a> 网络基础 TCP/IP</h3> <p>为了理解 HTTP，我们有必要事先了解一下 TCP/IP 协议族。</p> <p>通常使用的网络(包括互联网)是在 TCP/IP 协议族的基础上运作 的。而 HTTP 属于它内部的一个子集。</p> <p>接下来，我们仅介绍理解 HTTP 所需掌握的 TCP/IP 协议族的概要。</p> <h4 id="tcp-ip-协议族"><a href="#tcp-ip-协议族" class="header-anchor">#</a> <strong>TCP/IP</strong> 协议族</h4> <p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如， 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通 信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 协议(protocol)。</p> <p><img src="https://pic2.zhimg.com/80/v2-ceedc4fa404f250e36ec4fa432f48077_1440w.png" alt=""></p> <blockquote><p>上图为 <strong>TCP/IP</strong> 是互联网相关的各类协议族的总称</p></blockquote> <p>协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、 寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需 要处理的步骤，等等。</p> <p>像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法 认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/ IP 是在 IP 协议的通信过程中，使用到的协议族的统称。</p> <h4 id="tcp-ip-的分层管理"><a href="#tcp-ip-的分层管理" class="header-anchor">#</a> <strong>TCP/IP</strong> 的分层管理</h4> <p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分</p> <p>为以下 4 层:应用层、传输层、网络层和数据链路层。</p> <p>把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统 筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分 层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之 后，每个层次内部的设计就能够自由改动了。</p> <p>值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上 的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪 个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。</p> <p>TCP/IP 协议族各层的作用如下。</p> <ul><li><strong>应用层</strong>：应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP(File Transfer Protocol，文件传输协议)和 DNS(Domain Name System，域 名系统)服务就是其中两类。HTTP 协议也处于该层。</li> <li><strong>传输层</strong>：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。在传输层有两个性质不同的议:TCP(Transmission Control Protocol，传输控制协议)和 UDP(User Data Protocol，用户数据报 协议)。</li> <li>**网络层：**网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径(所谓的传输路线)到达对方计 算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路</li> <li><strong>链路层</strong>(又名数据链路层，网络接口层)：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC(Network Interface Card，网络适配器，即网卡)，及光纤等 物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在 链路层的作用范围之内。</li></ul> <h3 id="tcp-ip-通信传输流"><a href="#tcp-ip-通信传输流" class="header-anchor">#</a> <strong>TCP/IP</strong> 通信传输流</h3> <p><img src="https://pic3.zhimg.com/80/v2-3240d9089fd4b6af55f75112f4d26c76_1440w.png" alt=""></p> <p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通 信。发送端从应用层往下走，接收端则往应用层往上走。</p> <p>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层 (HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求。</p> <p>接着，为了传输方便，在传输层(TCP 协议)把从应用层处收到的数 据(HTTP 请求报文)进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。</p> <p>在网络层(IP 协议)，增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。</p> <p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。</p> <p><img src="https://pic4.zhimg.com/80/v2-32637fe0424992588d519362caa20de3_1440w.png" alt=""></p> <p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。</p> <p>这种把数据信息包装起来的做法称为封装(encapsulate)。</p> <h3 id="与-http-关系密切的协议-ip、tcp-和dns"><a href="#与-http-关系密切的协议-ip、tcp-和dns" class="header-anchor">#</a> 与 <strong>HTTP</strong> 关系密切的协议 <strong>: IP</strong>、<strong>TCP</strong> 和DNS</h3> <p>下面我们分别针对在 TCP/IP 协议族中与 HTTP 密不可分的 3 个协议 (IP、TCP 和 DNS)进行说明。</p> <h4 id="负责传输的-ip-协议"><a href="#负责传输的-ip-协议" class="header-anchor">#</a> 负责传输的 <strong>IP</strong> 协议</h4> <p>按层次分，IP(Internet Protocol)网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎 所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就 是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能 有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。</p> <p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址(Media Access Control Address)。</p> <p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</p> <p>使用 <strong>ARP</strong> 协议凭借 <strong>MAC</strong> 地址进行通信</p> <p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 (LAN)内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议(Address Resolution Protocol)。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p> <p>没有人能够全面掌握互联网中的传输状况</p> <p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。</p> <p>这种机制称为路由选择(routing)，有点像快递公司的送货过程。想 要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公 司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明 确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会 判断是否能送到对方的家中。</p> <p>我们是想通过这个比喻说明，无论哪台计算机、哪台网络设备，它们 都无法全面掌握互联网中的细节。</p> <p><img src="https://pic4.zhimg.com/80/v2-2cd84d4ea9000be7aec9369fa3cb4dff_1440w.png" alt=""></p> <h4 id="确保可靠性的-tcp-协议"><a href="#确保可靠性的-tcp-协议" class="header-anchor">#</a> 确保可靠性的 <strong>TCP</strong> 协议</h4> <p>按层次分，TCP 位于传输层，提供可靠的字节流服务。</p> <p>所谓的字节流服务(Byte Stream Service)是指，为了方便传输，将大 块数据分割成以报文段(segment)为单位的数据包进行管理。而可 靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方。</p> <p>确保数据能到达目标</p> <p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 (three-way handshaking)策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</p> <p>握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize) 和 ACK(acknowledgement)。</p> <p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</p> <p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。</p> <p><img src="https://pic4.zhimg.com/80/v2-e18b22cde01d5935b5086eda69468155_1440w.png" alt=""></p> <p>除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠 性。</p> <h4 id="负责域名解析的-dns-服务"><a href="#负责域名解析的-dns-服务" class="header-anchor">#</a> 负责域名解析的 <strong>DNS</strong> 服务</h4> <p>DNS(Domain Name System)服务是和 HTTP 协议一样位于应用层的</p> <p>协议。它提供域名到 IP 地址之间的解析服务。 计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如</p> <p>www.hackr.jp。</p> <p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表 示形式来指定计算机名更符合人类的记忆习惯。</p> <p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅 长处理一长串数字。</p> <p>为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p> <p><img src="https://pic2.zhimg.com/80/v2-f135ab135a4c6e708e6149ada7d7b410_1440w.png" alt=""></p> <h2 id="简单的http协议"><a href="#简单的http协议" class="header-anchor">#</a> 简单的HTTP协议</h2> <p>本章将针对 HTTP 协议结构进行讲解，主要使用HTTP/1.1版本。学完这章，想必大家就能理解 HTTP 协议的基础了。</p> <h3 id="http协议用于客户端和服务器端之间-的通信"><a href="#http协议用于客户端和服务器端之间-的通信" class="header-anchor">#</a> HTTP协议用于客户端和服务器端之间 的通信</h3> <p>HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和 服务器之间的通信。</p> <p>请求访问文本或图像等一系列资源的一端称为客户端，而提供资源响应的一 端称为服务器端。</p> <p><img src="https://pic1.zhimg.com/80/v2-9d0b37824c8153d7bc2755203bdf6367_1440w.png" alt=""></p> <p>在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有 一端是客户端，另一端则是服务器端。</p> <p>有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可 能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是 确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器 端。</p> <p><img src="https://pic1.zhimg.com/80/v2-83d687ce95f3e719acb9ff916921ed20_1440w.png" alt=""></p> <p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返 回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有 接收到请求之前不会发送响应。</p> <p><img src="https://pic3.zhimg.com/80/v2-437c54275145a6422980b8cb2f9a5e92_1440w.png" alt=""></p> <blockquote><p>客户端发送请求：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>htm <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>

Host<span class="token operator">:</span> hackr<span class="token punctuation">.</span>jp
</code></pre></div></blockquote> <blockquote><p>服务器发送响应</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
Data<span class="token operator">:</span>Tue<span class="token punctuation">,</span><span class="token number">10</span> Jul <span class="token number">2020</span> <span class="token number">06</span><span class="token operator">:</span><span class="token number">50</span><span class="token operator">:</span><span class="token number">15</span> <span class="token constant">GMT</span>
Cntent<span class="token punctuation">.</span>Length<span class="token operator">:</span><span class="token number">362</span>
Content<span class="token punctuation">.</span>Type<span class="token operator">:</span>text<span class="token operator">/</span>html
<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
  <span class="token operator">...</span>
</code></pre></div></blockquote> <p><strong>客户端</strong>：起始行开头的GET表示请求访问服务器的类型，称为方法 (method)。随后的字符串 /index.htm 指明了请求访问的资源对象， 也叫做请求 URI(request-URI)。最后的 HTTP/1.1，即 HTTP 的版本 号，用来提示客户端使用的 HTTP 协议功能。</p> <p>综合来看，这段请求内容的意思是:请求访问某台 HTTP 服务器上的 /index.htm 页面资源。</p> <p><strong>服务器</strong>：在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。</p> <p>紧挨着的 200 OK 表示请求的处理结果的状态码(status code)和原因 短语(reason-phrase)。下一行显示了创建响应的日期时间，是首部 字段(header field)内的一个属性。</p> <p>接着以一空行分隔，之后的内容称为资源实体的主体(entity body)。</p> <p>响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代 码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主 体构成。稍后我们会对这些内容进行详细说明。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* HTTP/1.1 协议版本
* 200      状态码
* OK       状态码的原因短语
*
* 下面为 响应首部字段
* Data:Tue,10 Jul 2020 06:50:15 GMT
* Cntent.Length:362
* Content.Type:text/html
*
*  下面为 主体
*  &lt;html&gt;
*  ...
*/</span>
</code></pre></div><p>以上就是响应报文的构成。</p> <h3 id="http是不保存状态的协议"><a href="#http是不保存状态的协议" class="header-anchor">#</a> HTTP是不保存状态的协议</h3> <p>HTTP 是一种不保存状态，即无状态(stateless)协议。HTTP 协议自 身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。</p> <blockquote><p>客户端(说：你之前发送了什么给我来着？)</p></blockquote> <blockquote><p>服务器(说：我想想，之前发送了什么给你来着？好像，我也不知道哦！)</p></blockquote> <p>以上即说明，<strong>HTTP</strong> 协议自身不具备保存之前发送过的请求或响应的功能</p> <p>使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了 更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设 计成如此简单的。</p> <p>可是，随着 Web 的不断发展，因无状态而导致业务处理变得棘手的 情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了 能够掌握是谁送出的请求，需要保存用户的状态。</p> <p>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。有关 Cookie 的详细内容稍后讲解。</p> <h3 id="请求uri定位资源"><a href="#请求uri定位资源" class="header-anchor">#</a> 请求URI定位资源</h3> <p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p> <p><img src="https://pic3.zhimg.com/80/v2-b7c88e705571339fd7803af55bfb8f98_1440w.png" alt="URI"></p> <blockquote><p>上图为<strong>HTTP</strong> 协议使用 <strong>URI</strong> 让客户端定位到资源</p></blockquote> <p>当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。指定请求 URI 的方式有很多。比如：</p> <ol><li><p>URI为完整的请求RUL</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>hackr<span class="token punctuation">.</span>jp<span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre></div></li> <li><p>在首部字段Host中写明网络域名或IP地址</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token operator">:</span> hackr<span class="token punctuation">.</span>jp
</code></pre></div></li></ol> <p>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 * 来代替请求 URI。下面这个例子是查询 HTTP 服务器端支持 的 HTTP 方法种类。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">OPTIONS</span> <span class="token operator">*</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre></div><h3 id="告知服务器意图的-http-方法"><a href="#告知服务器意图的-http-方法" class="header-anchor">#</a> 告知服务器意图的 <strong>HTTP</strong> 方法</h3> <p>下面，我们介绍 HTTP/1.1 中可使用的方法。</p> <p><strong>GET</strong> :获取资源</p> <p>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回;如果是像 CGI(Common Gateway Interface，通用网关接 口)那样的程序，则返回经过执行后的输出结果。</p> <p><img src="https://pic3.zhimg.com/80/v2-21804ff65474b5d8bdfe9c73a0315e2c_1440w.png" alt="资源"></p> <table><thead><tr><th>请求</th> <th>GET /index.html HTTP/1.1<br>Host: www.hackr.jp</th></tr></thead> <tbody><tr><td>响应</td> <td>返回index.html的页面资源</td></tr></tbody></table> <table><thead><tr><th>请求</th> <th>GET /index.html HTTP/1.1<br> Host: www.hackr.jp<br> If-Modified-Since: Thu, 12 Jul 2012 07:30:00 GMT</th></tr></thead> <tbody><tr><td>响应</td> <td>仅返回2012年7 月12日7 点30分以后更新过的index.html页面资源。如果未 有内容更新，则以状态码304 Not Modified作为响应返回</td></tr></tbody></table> <p><strong>POST</strong>:传输实体主体
POST 方法用来传输实体的主体。</p> <p>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</p> <p><img src="https://pic3.zhimg.com/80/v2-ab182825c3765e5b41a193e71b4196da_1440w.png" alt="post"></p> <table><thead><tr><th>请求</th> <th>POST /submit.cgi HTTP/1.1<br> Host: www.hackr.jp<br> Content-Length: 1560(1560字节的数据)</th></tr></thead> <tbody><tr><td>响应</td> <td>返回 submit.cgi 接收数据的处理结果</td></tr></tbody></table> <p><strong>PUT</strong>:传输文件</p> <p>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请</p> <p>求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</p> <p>但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST(REpresentational State Transfer，表征状态转移)标准的同类 Web 网站，就可能会开放使用 PUT 方法。</p> <p><img src="https://pic3.zhimg.com/80/v2-1756d9bf52549c770ee8cfebe5849fff_1440w.png" alt="put"></p> <table><thead><tr><th>请求</th> <th>PUT /example.html HTTP/1.1<br> Host: www.hackr.jp<br> Content-Type: text/html<br> Content-Length: 1560(1560 字节的数据)</th></tr></thead> <tbody><tr><td>响应</td> <td>返回 submit.cgi 接收数据的处理结果</td></tr></tbody></table> <p><strong>HEAD</strong>:获得报文首部</p> <p>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</p> <p><img src="https://pic2.zhimg.com/80/v2-0b23f0f27e4c963f12dfeb481dd882b8_1440w.png" alt="head"></p> <p>和 <strong>GET</strong> 一样，但不返回报文主体</p> <table><thead><tr><th>请求</th> <th>HEAD /index.html HTTP/1.1 Host: www.hackr.jp</th></tr></thead> <tbody><tr><td>响应</td> <td>返回index.html有关的响应首部</td></tr></tbody></table> <p><strong>DELETE</strong>:删除文件</p> <p>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。</p> <p>但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。</p> <p><img src="https://pic4.zhimg.com/80/v2-2ba157f6fa545f4ee40a5e789b062b27_1440w.png" alt="delete"></p> <table><thead><tr><th>请求</th> <th>DELETE /example.html HTTP/1.1 Host: www.hackr.jp</th></tr></thead> <tbody><tr><td>响应</td> <td>响应返回状态码 204 No Content(比如 :该 html 已从该服务器上删除)</td></tr></tbody></table> <p><strong>OPTIONS</strong>:询问支持的方法</p> <p>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</p> <p><img src="https://pic1.zhimg.com/80/v2-5cd11c2ebe6d0250ac6233fded546c85_1440w.png" alt="options"></p> <table><thead><tr><th>请求</th> <th>OPTIONS * HTTP/1.1 Host: www.hackr.jp</th></tr></thead> <tbody><tr><td>响应</td> <td>HTTP/1.1 200 OK<br> Allow: GET, POST, HEAD, OPTIONS (返回服务器支持的方法)</td></tr></tbody></table> <h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="header-anchor">#</a> 持久连接节省通信量</h3> <p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。</p> <p><img src="https://pic2.zhimg.com/80/v2-4e30c8a19e1dbd680396eff691cab20c_1440w.png" alt=""></p> <p>以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使 这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的 情况多了起来。</p> <p>比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送 请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断 开，增加通信量的开销。</p> <h3 id="持久连接"><a href="#持久连接" class="header-anchor">#</a> 持久连接</h3> <p>为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接(HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse)的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。</p> <p><img src="https://pic3.zhimg.com/80/v2-d74942352520d0e593977d5da42e5ac0_1440w.png" alt=""></p> <blockquote><p>持久连接旨在建立 <strong>1</strong> 次 <strong>TCP</strong> 连接后进行多次请求和响应的交 互</p></blockquote> <p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。</p> <p>在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并 未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接， 但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客 户端也需要支持持久连接。</p> <h3 id="管道化"><a href="#管道化" class="header-anchor">#</a> 管道化</h3> <p>持久连接使得多数请求以管道化(pipelining)方式发送成为可能。从 前发送请求后需等待并收到响应，才能发送下一个请求。管道化技术 出现后，不用等待响应亦可直接发送下一个请求。</p> <p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待 响应了。即异步请求。</p> <p><img src="https://pic2.zhimg.com/80/v2-13a2f759b3b3d18ff7ea730ee5fd807d_1440w.png" alt=""></p> <blockquote><p>上图所示，不需要等待响应，直接发送下一个请求。</p></blockquote> <p>比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相 比，用持久连接可以让请求更快结束。而管道化技术则比持久连接还 要快。请求数越多，时间差就越明显。</p> <h3 id="使用-cookie-的状态管理"><a href="#使用-cookie-的状态管理" class="header-anchor">#</a> 使用 <strong>Cookie</strong> 的状态管理</h3> <p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管</p> <p>理。也就是说，无法根据之前的状态进行本次的请求处理。</p> <p>假设要求登录认证的 Web 页面本身无法进行状态的管理(不记录已 登录的状态)，那么每次跳转新页面不是要再次登录，就是要在每次 请求报文中附加参数来管理登录状态。</p> <p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。</p> <p><img src="https://pic3.zhimg.com/80/v2-6684aee3f6227685ed8e276079a36923_1440w.png" alt=""></p> <blockquote><p>上图 如果让服务器管理全部客户端状态则会成为负担</p></blockquote> <p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。</p> <p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。</p> <p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。</p> <p><img src="https://pic3.zhimg.com/80/v2-850e3f92c83049c164c0bd8301790c72_1440w.png" alt=""></p> <blockquote><p>上图为 没有 <strong>Cookie</strong> 信息状态下的请求</p></blockquote> <p><img src="https://pic3.zhimg.com/80/v2-218733622e2bc5e2c75b13eb43e4a8f7_1440w.png" alt=""></p> <blockquote><p>上图为 第 <strong>2</strong> 次以后(存有 <strong>Cookie</strong> 信息状态)的请求</p></blockquote> <p>上面展示了发生 Cookie 交互的情景，HTTP 请求报文和响应报文的内 容如下。</p> <ol><li><p>请求报文(没有 <strong>Cookie</strong> 信息的状态)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span>reader<span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token operator">:</span> hackr<span class="token punctuation">.</span>jp <span class="token operator">*</span>首部字段内没有Cookie的相关信息
</code></pre></div></li> <li><p>响应报文(服务器端生成 <strong>Cookie</strong> 信息)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
Date<span class="token operator">:</span> Thu<span class="token punctuation">,</span> <span class="token number">12</span> Jul <span class="token number">2012</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">20</span> <span class="token constant">GMT</span>
Server<span class="token operator">:</span> Apache
<span class="token operator">&lt;</span>Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> sid<span class="token operator">=</span><span class="token number">1342077140226724</span><span class="token punctuation">;</span> path<span class="token operator">=</span><span class="token operator">/</span><span class="token punctuation">;</span> expires<span class="token operator">=</span>Wed<span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">-</span>Oct<span class="token operator">-</span><span class="token number">12</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">20</span> <span class="token constant">GMT</span><span class="token operator">&gt;</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain<span class="token punctuation">;</span> charset<span class="token operator">=</span><span class="token constant">UTF</span><span class="token operator">-</span><span class="token number">8</span>
</code></pre></div></li> <li><p>请求报文(自动发送保存着的 <strong>Cookie</strong> 信息)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span>image<span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token operator">:</span> hackr<span class="token punctuation">.</span>jp
Cookie<span class="token operator">:</span> sid<span class="token operator">=</span><span class="token number">1342077140226724</span>
</code></pre></div></li></ol> <h2 id="http报文内的http信息"><a href="#http报文内的http信息" class="header-anchor">#</a> HTTP报文内的HTTP信息</h2> <p>HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回 客户端的响应。</p> <h3 id="http-报文"><a href="#http-报文" class="header-anchor">#</a> <strong>HTTP</strong> 报文</h3> <p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端(客户端)的 HTTP 报文叫做请求报文，响应端(服务器端)的叫做响应报文。 HTTP 报文本身是由多行数据构成的字符串文 本。</p> <p>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的 空行来划分。通常，并不一定要有报文主体。</p> <p><img src="https://pic2.zhimg.com/80/v2-da5da5fdaebaafd36e4b86b829e1ccf1_1440w.png" alt=""></p> <blockquote><p>上图为 请求报文(上)和响应报文(下)的结构</p></blockquote> <h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="header-anchor">#</a> 编码提升传输速率</h3> <p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过 程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量 的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多 的 CPU 等资源。</p> <h4 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="header-anchor">#</a> 报文主体和实体主体的差异</h4> <ul><li><p><strong>报文(message)</strong></p> <p>是 HTTP 通信中的基本单位，由 8 位组字节流(octet sequence， 其中 octet 为 8 个比特)组成，通过 HTTP 通信传输。</p></li> <li><p><strong>实体(entity)</strong></p> <p>作为请求或响应的有效载荷数据(补充项)被传输，其内容由实</p></li></ul> <p>体首部和实体主体组成。
HTTP 报文的主体用于传输请求或响应的实体主体。</p> <p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体 主体的内容发生变化，才导致它和报文主体产生差异。</p> <h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="header-anchor">#</a> 压缩传输的内容编码</h4> <p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP 压缩文件之后再添加附件发送。HTTP 协议中有一种被称为内容编码 的功能也能进行类似的操作。</p> <p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p> <p><img src="https://pic4.zhimg.com/80/v2-a05f14d55a5f96c154ee0684460b1fcc_1440w.png" alt=""></p> <blockquote><p>上图为内容编码</p></blockquote> <p>常用的内容编码有以下几种。</p> <ul><li><strong>gzip</strong>(<strong>GNU zip</strong>)</li> <li><strong>compress</strong>(<strong>UNIX</strong> 系统的标准压缩)</li> <li><strong>deflate</strong>(<strong>zlib</strong>)</li> <li><strong>identity</strong>(不进行编码)</li></ul> <h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="header-anchor">#</a> 分割发送的分块传输编码</h4> <p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前， 浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成 多块，能够让浏览器逐步显示页面。</p> <p>这种把实体主体分块的功能称为分块传输编码(Chunked Transfer Coding)。</p> <p><img src="https://pic2.zhimg.com/80/v2-d15934a7554ed2f521a2d4e7a0a011a8_1440w.png" alt=""></p> <blockquote><p>上图为 分块传输编码</p></blockquote> <p>分块传输编码会将实体主体分成多个部分(块)。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。</p> <p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编 码前的实体主体。</p> <p>HTTP/1.1 中存在一种称为传输编码(Transfer Coding)的机制，它可 以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p> <h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="header-anchor">#</a> 发送多种数据的多部分对象集合</h3> <p><img src="https://pic3.zhimg.com/80/v2-088305a993cadcff1da5039d29e6799c_1440w.png" alt=""></p> <p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为 采用了 MIME(Multipurpose Internet Mail Extensions，多用途因特网邮 件扩展)机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明， 就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一 种称为多部分对象集合(Multipart)的方法，来容纳多份不同类型的 数据。</p> <p>相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p> <ul><li><p><strong>multipart/form-data</strong></p> <p>在 Web 表单文件上传时使用。</p></li> <li><p><strong>multipart/byte range s</strong></p> <p>状态码 206(Partial Content，部分内容)响应报文包含了多个范 围的内容时使用。</p></li> <li><p><strong>multipart/form-data</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Content<span class="token operator">-</span>Type<span class="token operator">:</span> multipart<span class="token operator">/</span>form<span class="token operator">-</span>data<span class="token punctuation">;</span> boundary<span class="token operator">=</span>AaB03x  
<span class="token operator">--</span>AaB03x
Content<span class="token operator">-</span>Disposition<span class="token operator">:</span> form<span class="token operator">-</span>data<span class="token punctuation">;</span> name<span class="token operator">=</span><span class="token string">&quot;field1&quot;</span>
 
Joe Blow
<span class="token operator">--</span>AaB03x
Content<span class="token operator">-</span>Disposition<span class="token operator">:</span> form<span class="token operator">-</span>data<span class="token punctuation">;</span> name<span class="token operator">=</span><span class="token string">&quot;pics&quot;</span><span class="token punctuation">;</span> filename<span class="token operator">=</span><span class="token string">&quot;file1.txt&quot;</span> Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
 
<span class="token operator">...</span><span class="token punctuation">(</span>file1<span class="token punctuation">.</span>txt的数据<span class="token punctuation">)</span><span class="token operator">...</span> <span class="token operator">--</span>AaB03x<span class="token operator">--</span>
</code></pre></div></li> <li><p><strong>multipart/byte range s</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">206</span> Partial Content
Date<span class="token operator">:</span> Fri<span class="token punctuation">,</span> <span class="token number">13</span> Jul <span class="token number">2012</span> <span class="token number">02</span><span class="token operator">:</span><span class="token number">45</span><span class="token operator">:</span><span class="token number">26</span> <span class="token constant">GMT</span>
Last<span class="token operator">-</span>Modified<span class="token operator">:</span> Fri<span class="token punctuation">,</span> <span class="token number">31</span> Aug <span class="token number">2007</span> <span class="token number">02</span><span class="token operator">:</span><span class="token number">02</span><span class="token operator">:</span><span class="token number">20</span> <span class="token constant">GMT</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> multipart<span class="token operator">/</span>byteranges<span class="token punctuation">;</span> boundary<span class="token operator">=</span><span class="token constant">THIS_STRING_SEPARATES</span>
<span class="token operator">--</span><span class="token constant">THIS_STRING_SEPARATES</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> application<span class="token operator">/</span>pdf Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">500</span><span class="token operator">-</span><span class="token number">999</span><span class="token operator">/</span><span class="token number">8000</span>
<span class="token operator">...</span><span class="token punctuation">(</span>范围指定的数据<span class="token punctuation">)</span><span class="token operator">...</span> <span class="token operator">--</span><span class="token constant">THIS_STRING_SEPARATES</span> Content<span class="token operator">-</span>Type<span class="token operator">:</span> application<span class="token operator">/</span>pdf Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">7000</span><span class="token operator">-</span><span class="token number">7999</span><span class="token operator">/</span><span class="token number">8000</span>
<span class="token operator">...</span><span class="token punctuation">(</span>范围指定的数据<span class="token punctuation">)</span><span class="token operator">...</span> <span class="token operator">--</span><span class="token constant">THIS_STRING_SEPARATES</span><span class="token operator">--</span>
</code></pre></div></li></ul> <p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。有关这个首部字段，我们稍后讲解。</p> <p>使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“--”标记(例如:- -AaB03x、--THIS_STRING_SEPARATES)，而在多部分对象集合对 应的字符串的最后插入“--”标记(例如:--AaB03x--、-- THIS_STRING_SEPARATES--)作为结束。</p> <p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可 以在某个部分中嵌套使用多部分对象集合。有关多部分对象集合更详 细的解释，请参考 RFC2046。</p> <h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="header-anchor">#</a> 获取部分内容的范围请求</h3> <p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一 个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络 中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢 复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p> <p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求(Range Request)。</p> <p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p> <p><img src="https://pic1.zhimg.com/80/v2-abba2c24d486fc0618996b37c26a4c7a_1440w.png" alt="资源"></p> <p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p> <p>byte 范围的指定形式如下。</p> <ul><li><p><strong>5001~10 000</strong> 字节</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Range<span class="token operator">:</span> bytes<span class="token operator">=</span><span class="token number">5001</span><span class="token operator">-</span><span class="token number">10000</span>
</code></pre></div></li> <li><p>从 <strong>5001</strong> 字节之后全部的</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Range<span class="token operator">:</span> bytes<span class="token operator">=</span><span class="token number">5001</span><span class="token operator">-</span>
</code></pre></div></li> <li><p>从一开始到 <strong>3000</strong> 字节和 <strong>5000~7000</strong> 字节的多重范围</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Range<span class="token operator">:</span> bytes<span class="token operator">=</span><span class="token operator">-</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token operator">-</span><span class="token number">7000</span>
</code></pre></div></li></ul> <p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报 文。另外，对于多重范围的范围请求，响应会在首部字段 Content- Type 标明 multipart/byteranges 后返回响应报文。</p> <p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的 实体内容。</p> <h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="header-anchor">#</a> 内容协商返回最合适的内容</h3> <p>同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和</p> <p>中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。</p> <p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商(Content Negotiation)。</p> <p><img src="https://pic1.zhimg.com/80/v2-1cc25abaa3bae30d38e64869ea20a770_1440w.png" alt="google搜索"></p> <blockquote><p>上图为访问google搜索</p></blockquote> <p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然 后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字 符集、编码方式等作为判断的基准。</p> <p>包含在请求报文中的某些首部字段(如下)就是判断的基准。这些首 部字段的详细说明请参考下一章。</p> <ul><li><strong>Acce pt</strong></li> <li><strong>Acce pt-Charse t</strong></li> <li><strong>Acce pt-Encoding</strong></li> <li><strong>Acce pt-Language</strong></li> <li><strong>Conte nt-Language</strong></li></ul> <p>内容协商技术有以下 3 种类型。</p> <p>服务器驱动协商(<strong>Server-driven Negotiation</strong>)</p> <p>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自 动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不 一定能筛选出最优内容。</p> <p>客户端驱动协商(<strong>Agent-driven Negotiation</strong>)</p> <p>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手 动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选 择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机 版页面。</p> <p>透明协商(<strong>Transparent Negotiation</strong>)</p> <p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进 行内容协商的一种方法。</p> <h2 id="返回结果的-http-状态-码"><a href="#返回结果的-http-状态-码" class="header-anchor">#</a> 返回结果的 <strong>HTTP</strong> 状态 码</h2> <p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作。让我们通过本章的学习， 好好了解一下状态码的工作机制。</p> <h3 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="header-anchor">#</a> 状态码告知从服务器端返回的请求结果</h3> <p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结 果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。</p> <p><img src="https://pic3.zhimg.com/80/v2-059cfab4f18d30000cda0617876991ae_1440w.png" alt=""></p> <blockquote><p>上图 响应的状态码可描述请求的处理结果</p></blockquote> <p>状态码如 200 OK，以 3 位数字和原因短语组成。</p> <p>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。</p> <table><thead><tr><th>状态码</th> <th>类别</th> <th>原因短语</th></tr></thead> <tbody><tr><td>1XX</td> <td>Informational(信息性状态码)</td> <td>接收的请求正在处理</td></tr> <tr><td>2XX</td> <td>Success(成功状态码)</td> <td>请求正常处理完毕</td></tr> <tr><td>3XX</td> <td>Redirection(重定向状态码)</td> <td>需要进行附加操作以完成请求</td></tr> <tr><td>4XX</td> <td>Client Error(客户端错误状态码)</td> <td>服务器无法处理请求</td></tr> <tr><td>5XX</td> <td>Server Error(服务器错误状态码)</td> <td>服务器处理请求出错</td></tr></tbody></table> <p>只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码， 或服务器端自行创建状态码都没问题。</p> <p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV(Web-based Distributed Authoring and Versioning，基于万维网 的分布式创作和版本控制)(RFC4918、5842) 和附加 HTTP 状态码 (RFC6585)等扩展，数量就达 60 余种。别看种类繁多，实际上经 常使用的大概只有 14 种。接下来，我们就介绍一下这些具有代表性 的 14 个状态码。</p> <h3 id="_2xx-成功"><a href="#_2xx-成功" class="header-anchor">#</a> <strong>2XX</strong> 成功</h3> <p>2XX 的响应结果表明请求被正常处理了。</p> <h4 id="_200-ok"><a href="#_200-ok" class="header-anchor">#</a> <strong>200 OK</strong></h4> <p><img src="https://pic2.zhimg.com/80/v2-c623f19085771ba058de23a72ad9e3ec_1440w.png" alt=""></p> <p>表示从客户端发来的请求在服务器端被正常处理了。</p> <p>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改 变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返 回;而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体 作为响应返回(即在响应中只返回首部，不会返回实体的主体部 分)。</p> <h4 id="_204-no-content"><a href="#_204-no-content" class="header-anchor">#</a> <strong>204 No Content</strong></h4> <p><img src="https://pic3.zhimg.com/80/v2-79c5221f692b1c16f5d0bcf06f921bc2_1440w.png" alt=""></p> <p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。另外，也不允许返回任何实体的主体。比如， 当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面 不发生更新。</p> <p>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p> <h3 id="_3xx-重定向"><a href="#_3xx-重定向" class="header-anchor">#</a> <strong>3XX</strong> 重定向</h3> <p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请</p> <p>求。</p> <h4 id="_301-moved-permanently"><a href="#_301-moved-permanently" class="header-anchor">#</a> <strong>301 Moved Permanently</strong></h4> <p><img src="https://pic1.zhimg.com/80/v2-533162f39063316ac923cd6f3028fee0_1440w.png" alt=""></p> <p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p> <h4 id="_302-found"><a href="#_302-found" class="header-anchor">#</a> <strong>302 Found</strong></h4> <p><img src="https://pic1.zhimg.com/80/v2-e9d679e0c684e0ef8d1f182b17339f8a_1440w.png" alt=""></p> <p>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户(本次)能使用新的 URI 访问。</p> <p>和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不 是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会 像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码 的页面对应的 URI。</p> <h4 id="_304-not-modified"><a href="#_304-not-modified" class="header-anchor">#</a> <strong>304 Not Modified</strong></h4> <p><img src="https://pic2.zhimg.com/80/v2-4ae7e039f79b1abb7cfd14f686769f13_1440w.png" alt=""></p> <p>该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访 问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系。</p> <h3 id="_4xx-客户端错误"><a href="#_4xx-客户端错误" class="header-anchor">#</a> <strong>4XX</strong> 客户端错误</h3> <p>4XX 的响应结果表明客户端是发生错误的原因所在。</p> <h4 id="_400-bad-request"><a href="#_400-bad-request" class="header-anchor">#</a> <strong>400 Bad Request</strong></h4> <p><img src="https://pic3.zhimg.com/80/v2-57674f5758b5573056b165e318c96b80_1440w.png" alt=""></p> <p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求 的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态 码。</p> <h4 id="_401-unauthorized"><a href="#_401-unauthorized" class="header-anchor">#</a> <strong>401 Unauthorized</strong></h4> <p><img src="https://pic3.zhimg.com/80/v2-bab2ea472715abbc50d275488fda2eb4_1440w.png" alt=""></p> <p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、 DIGEST 认证)的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。</p> <h4 id="_403-forbidden"><a href="#_403-forbidden" class="header-anchor">#</a> <strong>403 Forbidden</strong></h4> <p><img src="https://pic1.zhimg.com/80/v2-50c750a28a8781a9f5e037514fc7b49d_1440w.png" alt=""></p> <p>该状态码表明对请求资源的访问被服务器拒绝了。</p> <h4 id="_404-not-found"><a href="#_404-not-found" class="header-anchor">#</a> <strong>404 Not Found</strong></h4> <p><img src="https://pic1.zhimg.com/80/v2-be3a7f4fe071adc290deda6609972c91_1440w.png" alt=""></p> <p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服 务器端拒绝请求且不想说明理由时使用。</p> <h3 id="_5xx-服务器错误"><a href="#_5xx-服务器错误" class="header-anchor">#</a> <strong>5XX</strong> 服务器错误</h3> <p>5XX 的响应结果表明服务器本身发生错误。</p> <h4 id="_500-internal-server-error"><a href="#_500-internal-server-error" class="header-anchor">#</a> <strong>500 Internal Server Error</strong></h4> <p><img src="https://pic4.zhimg.com/80/v2-179162cbbf7e7bdca6c2d04d22ae3ad2_1440w.png" alt=""></p> <p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p> <h4 id="_503-service-unavailable"><a href="#_503-service-unavailable" class="header-anchor">#</a> <strong>503 Service Unavailable</strong></h4> <p><img src="https://pic2.zhimg.com/80/v2-fa788dc37670525e47e0eb12d186272f_1440w.png" alt=""></p> <p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。</p> <h2 id="与http协作的web服-务器"><a href="#与http协作的web服-务器" class="header-anchor">#</a> 与<strong>HTTP</strong>协作的<strong>Web</strong>服 务器</h2> <p>一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路 径上的中转服务器提升传输效率。</p> <h3 id="用单个服务器主机实现多个域名"><a href="#用单个服务器主机实现多个域名" class="header-anchor">#</a> 用单个服务器主机实现多个域名</h3> <p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提 供 Web 托管服务(Web Hosting Service)的供应商，可以用一台服务 器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网 站。这是因为利用了虚拟主机(Virtual Host，又称虚拟服务器)的功 能。</p> <p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以 假想已具有多台服务器。</p> <p><img src="https://pic2.zhimg.com/80/v2-794bfc847eb382f34fc72aa8ccb2938a_1440w.png" alt=""></p> <p>客户端使用 HTTP 协议访问服务器时，会经常采用类似 www.hackr.jp 这样的主机名和域名。</p> <p>在互联网上，域名通过 DNS 服务映射到 IP 地址(域名解析)之后访 问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式 访问了。</p> <p>所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这 两个域名，使用DNS服务器解析域名后，两者访问的是相同的IP地址。</p> <p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名 的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指 定主机名或域名的 URI。</p> <h3 id="通信数据转发程序-代理、网关、隧-道"><a href="#通信数据转发程序-代理、网关、隧-道" class="header-anchor">#</a> 通信数据转发程序 :代理、网关、隧 道</h3> <p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发 的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。</p> <p>这些应用程序和服务器可以将请求转发给通信线路上的下一站服务 器，并且能接收从那台服务器发送的响应再转发给客户端。</p> <h3 id="代理"><a href="#代理" class="header-anchor">#</a> 代理</h3> <p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户 端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时 也接收服务器返回的响应并转发给客户端。（比如：<strong>nginx</strong>）。</p> <p><img src="https://pic1.zhimg.com/80/v2-d2dd7b4fc336b3160f6a218a22210da0_1440w.png" alt=""></p> <p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务 器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务 器。</p> <p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过 代理服务器后再传给客户端。</p> <p>使用代理服务器的好处有:利用缓存技术(稍后讲解)减少网络带宽 的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要 目的，等等。</p> <p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一 种是是否会修改报文。</p> <h4 id="缓存代理"><a href="#缓存代理" class="header-anchor">#</a> 缓存代理</h4> <p>代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本 (缓存)保存在代理服务器上。</p> <p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获 取资源，而是将之前缓存的资源作为响应返回。</p> <h4 id="透明代理"><a href="#透明代理" class="header-anchor">#</a> 透明代理</h4> <p>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 (Transparent Proxy)。反之，对报文内容进行加工的代理被称为非 透明代理。</p> <h3 id="网关"><a href="#网关" class="header-anchor">#</a> 网关</h3> <p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请 求时，它就像自己拥有资源的源服务器一样对请求进行处理。</p> <p><img src="https://pic4.zhimg.com/80/v2-a497041f5be320836e5ba8d15a9e3c8f_1440w.png" alt=""></p> <blockquote><p>上图：利用网关可以由 <strong>HTTP</strong> 请求转化为其他协议通信 网关的工作机制和代理十分相似。而网关能使通信线</p></blockquote> <p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道关口，这道关口就是网关。顾名思义，网关 就是一个网络连接到另一个网络的“关口”。也就是网络关卡。</p> <p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。</p> <h4 id="隧道"><a href="#隧道" class="header-anchor">#</a> 隧道</h4> <p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。</p> <p>隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。</p> <p><img src="https://pic1.zhimg.com/80/v2-26c0ff8fc8e52e740d4ef228bc4754af_1440w.png" alt=""></p> <blockquote><p>上图：通过隧道的传输，可以和远距离的服务器安全通信。隧道本 身是透明的，客户端不用在意隧道的存在</p></blockquote> <h2 id="http首部"><a href="#http首部" class="header-anchor">#</a> HTTP首部</h2> <p>HTTP 协议的请求和响应报文中必定包含 HTTP 首部，只是我们平时 在使用 Web 的过程中感受不到它。本章我们一起来学习 HTTP 首部 的结构，以及首部中各字段的用法。</p> <p><img src="https://pic2.zhimg.com/80/v2-20a9695544c9c99d76c09e04ddb67fa7_1440w.png" alt=""></p> <blockquote><p>上图：<strong>HTTP</strong> 报文的结构</p></blockquote> <p>HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。</p> <h3 id="http-请求报文"><a href="#http-请求报文" class="header-anchor">#</a> HTTP 请求报文</h3> <p>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。</p> <p>下面的示例是访问 http://hackr.jp 时，请求报文的首部信息。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token operator">:</span> hackr<span class="token punctuation">.</span>jp
User<span class="token operator">-</span>Agent<span class="token operator">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span> <span class="token punctuation">(</span>Windows <span class="token constant">NT</span> <span class="token number">6.1</span><span class="token punctuation">;</span> <span class="token constant">WOW64</span><span class="token punctuation">;</span> rv<span class="token operator">:</span><span class="token number">13.0</span><span class="token punctuation">)</span> Ge Accept<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">,</span>application<span class="token operator">/</span>xhtml<span class="token operator">+</span>xml<span class="token punctuation">,</span>application<span class="token operator">/</span>xml<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.</span> Accept<span class="token operator">-</span>Language<span class="token operator">:</span> ja<span class="token punctuation">,</span>en<span class="token operator">-</span>us<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span>en<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.3</span>
Accept<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip<span class="token punctuation">,</span> deflate
<span class="token constant">DNT</span><span class="token operator">:</span> <span class="token number">1</span>
Connection<span class="token operator">:</span> keep<span class="token operator">-</span>alive
If<span class="token operator">-</span>Modified<span class="token operator">-</span>Since<span class="token operator">:</span> Fri<span class="token punctuation">,</span> <span class="token number">31</span> Aug <span class="token number">2007</span> <span class="token number">02</span><span class="token operator">:</span><span class="token number">02</span><span class="token operator">:</span><span class="token number">20</span> <span class="token constant">GMT</span> If<span class="token operator">-</span>None<span class="token operator">-</span>Match<span class="token operator">:</span> <span class="token string">&quot;45bae1-16a-46d776ac&quot;</span>
Cache<span class="token operator">-</span>Control<span class="token operator">:</span> max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">0</span>
</code></pre></div><h3 id="http-响应报文"><a href="#http-响应报文" class="header-anchor">#</a> <strong>HTTP</strong> 响应报文</h3> <p>在响应中，HTTP 报文由 HTTP 版本、状态码(数字和原因短语)、 HTTP 首部字段 3 部分构成。</p> <p><img src="https://pic4.zhimg.com/80/v2-5daced1eacb85f18feb0ab810d693201_1440w.png" alt=""></p> <p>以下示例是之前请求访问 http://hackr.jp/ 时，返回的响应报文的首部 信息。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">304</span> Not Modified
Date<span class="token operator">:</span> Thu<span class="token punctuation">,</span> <span class="token number">07</span> Jun <span class="token number">2012</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span><span class="token number">36</span> <span class="token constant">GMT</span> Server<span class="token operator">:</span> Apache
Connection<span class="token operator">:</span> close
Etag<span class="token operator">:</span> <span class="token string">&quot;45bae1-16a-46d776ac&quot;</span>
</code></pre></div><p>在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部 字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信 息。</p> <p>因 HTTP 版本或扩展规范的变化，首部字段可支持的字段内容略有不 同。这里主要涉及 HTTP/1.1 及常用的首部字段。</p> <h3 id="http-首部字段"><a href="#http-首部字段" class="header-anchor">#</a> HTTP 首部字段</h3> <p>HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之 间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首 部字段，它能起到传递额外重要信息的作用。</p> <p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的 语言、认证信息等内容。</p> <h4 id="http首部字段结构"><a href="#http首部字段结构" class="header-anchor">#</a> HTTP首部字段结构</h4> <p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html
</code></pre></div><p>另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Keep<span class="token operator">-</span>Alive<span class="token operator">:</span> timeout<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">100</span>
</code></pre></div><h4 id="_4-种-http-首部字段类型"><a href="#_4-种-http-首部字段类型" class="header-anchor">#</a> <strong>4</strong> 种 <strong>HTTP</strong> 首部字段类型</h4> <p>HTTP 首部字段根据实际用途被分为以下 4 种类型。</p> <p>通用首部字段(<strong>General Header Fields</strong>)</p> <p>请求报文和响应报文两方都会使用的首部。</p> <p>请求首部字段(<strong>Request Header Fields</strong>)</p> <p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加 内容、客户端信息、响应内容相关优先级等信息。</p> <p>响应首部字段(<strong>Response Header Fields</strong>) 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加</p> <p>内容，也会要求客户端附加额外的内容信息。 实体首部字段(<strong>Entity Header Fields</strong>)</p> <p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更 新时间等与实体有关的信息。</p> <h3 id="_4-种-http-首部字段类型-2"><a href="#_4-种-http-首部字段类型-2" class="header-anchor">#</a> <strong>4</strong> 种 <strong>HTTP</strong> 首部字段类型</h3> <h4 id="通用首部字段"><a href="#通用首部字段" class="header-anchor">#</a> 通用首部字段</h4> <p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Cache-Control</td> <td>控制缓存的行为</td></tr> <tr><td>Connection</td> <td>逐跳首部、连接的管理</td></tr> <tr><td>Date</td> <td>创建报文的日期时间</td></tr> <tr><td>Pragma</td> <td>报文指令</td></tr> <tr><td>Trailer</td> <td>报文末端的首部一览</td></tr> <tr><td>Transfer-Encoding</td> <td>指定报文主体的传输编码方式</td></tr> <tr><td>Upgrade</td> <td>升级为其他协议</td></tr> <tr><td>Via</td> <td>代理服务器的相关信息</td></tr> <tr><td>Warning</td> <td>错误通知</td></tr></tbody></table> <h4 id="请求首部字段"><a href="#请求首部字段" class="header-anchor">#</a> 请求首部字段</h4> <p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等 内容。</p> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Accept</td> <td>用户代理可处理的媒体类型</td></tr> <tr><td>Accept-Charset</td> <td>优先的字符集</td></tr> <tr><td>Accept-Encoding</td> <td>优先的内容编码</td></tr> <tr><td>Accept-Language</td> <td>优先的语言(自然语言)</td></tr> <tr><td>Authorization</td> <td>Web认证信息</td></tr> <tr><td>Expect</td> <td>期待服务器的特定行为</td></tr> <tr><td>From</td> <td>用户的电子邮箱地址</td></tr> <tr><td>Host</td> <td>请求资源所在服务器</td></tr> <tr><td>If-Match</td> <td>比较实体标记(ETag)</td></tr> <tr><td>If-Modified-Since</td> <td>比较资源的更新时间</td></tr> <tr><td>If-None-Match</td> <td>比较实体标记(与 If-Match 相反)</td></tr> <tr><td>If-Range</td> <td>资源未更新时发送实体 Byte 的范围请求</td></tr> <tr><td>If-Unmodified-Since</td> <td>比较资源的更新时间(与If-Modified-Since相反）</td></tr> <tr><td>Max-Forwards</td> <td>最大传输逐跳数</td></tr> <tr><td>Proxy-Authorization</td> <td>代理服务器要求客户端的认证信息</td></tr> <tr><td>Range</td> <td>实体的字节范围请求</td></tr> <tr><td>Referer</td> <td>对请求中 URI 的原始获取方</td></tr> <tr><td>TE</td> <td>传输编码的优先级</td></tr> <tr><td>User-Agent</td> <td>HTTP 客户端程序的信息</td></tr></tbody></table> <h4 id="响应首部字段"><a href="#响应首部字段" class="header-anchor">#</a> 响应首部字段</h4> <p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等 信息。</p> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Accept-Ranges</td> <td>是否接受字节范围请求</td></tr> <tr><td>Age</td> <td>推算资源创建经过时间</td></tr> <tr><td>ETag</td> <td>资源的匹配信息</td></tr> <tr><td>Location</td> <td>令客户端重定向至指定URI</td></tr> <tr><td>Proxy-Authenticate</td> <td>代理服务器对客户端的认证信息</td></tr> <tr><td>Retry-After</td> <td>对再次发起请求的时机要求</td></tr> <tr><td>Server</td> <td>HTTP服务器的安装信息</td></tr> <tr><td>Vary</td> <td>代理服务器缓存的管理信息</td></tr> <tr><td>WWW-Authenticate</td> <td>服务器对客户端的认证信息</td></tr></tbody></table> <h4 id="实体首部字段"><a href="#实体首部字段" class="header-anchor">#</a> 实体首部字段</h4> <table><thead><tr><th>首部字段名</th> <th>说明</th></tr></thead> <tbody><tr><td>Allow</td> <td>资源可支持的HTTP方法</td></tr> <tr><td>Content-Encoding</td> <td>实体主体适用的编码方式</td></tr> <tr><td>Content-Language</td> <td>实体主体的自然语言</td></tr> <tr><td>Content-Length</td> <td>实体主体的大小(单位:字节)</td></tr> <tr><td>Content-Location</td> <td>替代对应资源的URI</td></tr> <tr><td>Content-MD5</td> <td>实体主体的报文摘要</td></tr> <tr><td>Content-Range</td> <td>实体主体的位置范围</td></tr> <tr><td>Content-Type</td> <td>实体主体的媒体类型</td></tr> <tr><td>Expires</td> <td>实体主体过期的日期时间</td></tr> <tr><td>Last-Modified</td> <td>资源的最后修改日期时间</td></tr></tbody></table> <h2 id="确保web安全的-https"><a href="#确保web安全的-https" class="header-anchor">#</a> 确保<strong>Web</strong>安全的 <strong>HTTPS</strong></h2> <p>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。</p> <h3 id="http-的缺点"><a href="#http-的缺点" class="header-anchor">#</a> <strong>HTTP</strong> 的缺点</h3> <p>到现在为止，我们已了解到 HTTP 具有相当优秀和方便的一面，然而</p> <p>HTTP 并非只有好的一面，事物皆具两面性，它也是有不足之处的。 HTTP 主要有这些不足，例举如下。</p> <ul><li><p>通信使用明文(不加密)，内容可能会被窃听</p></li> <li><p>不验证通信方的身份，因此有可能遭遇伪装</p></li> <li><p>无法证明报文的完整性，所以有可能已遭篡改</p></li></ul> <p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问 题。</p> <p>除此之外，HTTP 本身还有很多缺点。而且，还有像某些特定的 Web 服务器和特定的 Web 浏览器在实际应用中存在的不足(也可以说成 是脆弱性或安全漏洞)，另外，用 Java 和 PHP 等编程语言开发的 Web 应用也可能存在安全漏洞。</p> <h3 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="header-anchor">#</a> 通信使用明文可能会被窃听</h3> <p>由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体(使 用 HTTP 协议通信的请求和响应的内容)进行加密。即，HTTP 报文 使用明文(指未经过加密的报文)方式发送。</p> <ul><li><strong>TCP/IP</strong> 是可能被窃听的网络</li> <li>加密处理防止被窃听(用SSL加密HTTP的通信内容)</li></ul> <h3 id="不验证通信方的身份就可能遭遇伪装"><a href="#不验证通信方的身份就可能遭遇伪装" class="header-anchor">#</a> 不验证通信方的身份就可能遭遇伪装</h3> <p>在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何 人都可以发起请求。</p> <p><img src="https://pic4.zhimg.com/80/v2-950fc1c7ddd64f7c825a96c176068dd9_1440w.png" alt=""></p> <p>HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会 返回响应，因此不确认通信方，则会存在很多隐患。</p> <p>这个时候我们就需要查明对手的证书，虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。 SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方。</p> <p><img src="https://pic1.zhimg.com/80/v2-27a82733fb3861146b4e197921db98ef_1440w.png" alt=""></p> <h3 id="无法证明报文完整性-可能已遭篡改"><a href="#无法证明报文完整性-可能已遭篡改" class="header-anchor">#</a> 无法证明报文完整性，可能已遭篡改</h3> <p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味 着无法判断信息是否准确。为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加 密处理及摘要功能。</p> <h3 id="http-加密-认证-完整性保护-https"><a href="#http-加密-认证-完整性保护-https" class="header-anchor">#</a> <strong>HTTP+</strong> 加密 <strong>+</strong> 认证 <strong>+</strong> 完整性保护 <strong>=HTTPS</strong></h3> <p><img src="https://pic2.zhimg.com/80/v2-db19957bef4d96c55e40c84a0f6b3a72_1440w.png" alt=""></p> <p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代 替而已。</p> <p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通 信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p> <p><img src="https://pic1.zhimg.com/80/v2-422f3c216203df47118b6e0675e7d049_1440w.png" alt=""></p> <p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护 这些功能。</p> <h3 id="为什么不一直使用-https"><a href="#为什么不一直使用-https" class="header-anchor">#</a> 为什么不一直使用 HTTPS</h3> <p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平 摊到一台计算机上时，能够处理的请求数量必定也会随之减少。特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们 所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都 进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资 源。</p> <p>除此之外，想要节约购买证书的开销也是原因之一。</p> <p>要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认 证机构(CA)购买。证书价格可能会根据不同的认证机构略有不 同。对于个人开发者，或许小型团队来讲，话额外的钱购买https证书并不合算。</p> <h2 id="确认访问用户身份的认-证"><a href="#确认访问用户身份的认-证" class="header-anchor">#</a> 确认访问用户身份的认 证</h2> <h3 id="何为认证"><a href="#何为认证" class="header-anchor">#</a> 何为认证</h3> <p>计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无 法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务 器，就得让对方的客户端自报家门。</p> <p>可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这 点却也无从谈起。为确认 ueno 本人是否真的具有访问系统的权限， 就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信 息”。</p> <p>核对的信息通常是指以下这些。</p> <ul><li><p>密码:只有本人才会知道的字符串信息。</p></li> <li><p>动态令牌:仅限本人持有的设备内显示的一次性密码。</p></li> <li><p>数字证书:仅限本人(终端)持有的信息。</p></li> <li><p>生物认证:指纹和虹膜等本人的生理信息。</p></li> <li><p>IC卡等:仅限本人持有的信息。</p></li></ul> <h3 id="http-使用的认证方式"><a href="#http-使用的认证方式" class="header-anchor">#</a> <strong>HTTP</strong> 使用的认证方式</h3> <ul><li>BASIC 认证(基本认证)</li> <li>DIGEST 认证(摘要认证)</li> <li>SSL客户端认证</li> <li>FormBase认证(基于表单认证)</li></ul> <h3 id="web-的攻击技术"><a href="#web-的攻击技术" class="header-anchor">#</a> <strong>Web</strong> 的攻击技术</h3> <p>HTTP 就是一个通用的单纯协议机制。简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会 成为攻击的对象。应用 HTTP 协议的服务器和客户端，以及运行在服 务器上的 Web 应用等资源才是攻击目标。</p> <ol><li><p><strong>在客户端即可篡改请求</strong></p> <p>在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。 通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传 入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或 被攻击者拿到管理权限。</p></li> <li><p><strong>针对 Web应用的攻击模式</strong></p> <ul><li>主动攻击：主动攻击(active attack)是指攻击者通过直接访问 Web 应用， 把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的 资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注 入攻击。</li> <li>被动攻击：被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻 击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访 问发起攻击。被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求 伪造。</li></ul></li> <li><p><strong>因会话管理疏忽引发的安全漏洞</strong></p> <ul><li>会话劫持：会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会 话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</li> <li>跨站点请求伪造：跨站点请求伪造(Cross-Site Request Forgeries，CSRF)攻击是指攻击 者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信 息或设定信息等某些状态更新，属于被动攻击。</li></ul></li> <li><p><strong>其他安全漏洞</strong></p> <ul><li><p>密码破解：密码破解攻击(Password Cracking)即算出密码，突破认证。攻击不 仅限于 Web 应用，还包括其他的系统(如 FTP 或 SSH 等)，本节将 会讲解对具备认证功能的 Web 应用进行的密码破解。</p></li> <li><p>点击劫持：点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱，覆盖 在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接 访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。</p></li> <li><p><strong>DoS</strong> 攻击：DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状 态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对 象不仅限于 Web 网站，还包括网络设备及服务器等。</p></li> <li><p>后门程序：后门程序(Backdoor)是指开发设置的隐藏入口，可不按正常步骤使</p> <p>用受限功能。利用后门程序就能够使用原本受限制的功能。</p></li></ul></li></ol> <h2 id="ajax和websocket"><a href="#ajax和websocket" class="header-anchor">#</a> ajax和websocket</h2> <h3 id="http-的瓶颈"><a href="#http-的瓶颈" class="header-anchor">#</a> <strong>HTTP</strong> 的瓶颈</h3> <p>在 Facebook 和 Twitter 等 SNS 网站上，几乎能够实时观察到海量用户 公开发布的内容，这也是一种乐趣。当几百、几千万的用户发布内容 时，Web 网站为了保存这些新增内容，在很短的时间内就会发生大量 的内容更新。</p> <p>为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就 需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的， 但 HTTP 却无法妥善地处理好这项任务。</p> <p>使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户 端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生 徒劳的通信。</p> <p>若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶 颈。</p> <ul><li>一条连接上只可发送一个请求。</li> <li>请求只能从客户端开始。客户端不可以接收除响应以外的指 令。</li> <li>请求 <strong>/</strong> 响应首部未经压缩就发送。首部信息越多延迟越大。</li> <li>发送冗长的首部。每次互相发送相同的首部造成的浪费较 多。</li> <li>可任意选择数据压缩格式。非强制压缩发送。</li></ul> <h3 id="ajax-的解决方法"><a href="#ajax-的解决方法" class="header-anchor">#</a> <strong>Ajax</strong> 的解决方法</h3> <p>Ajax(Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技 术)是一种有效利用 JavaScript 和 DOM(Document Object Model，文 档对象模型)的操作，以达到局部 Web 页面替换加载的异步通信手 段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输 的数据量会因此而减少，这一优点显而易见。</p> <p>Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本 语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已 加载完毕的 Web 页面上发起请求，只更新局部页面。</p> <p>而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产 生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。</p> <h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> <strong>WebSocket</strong></h3> <p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题 在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p> <p>当时筹划将 WebSocket 作为 HTML5 标准的一部分，而现在它却逐渐 变成了独立的协议标准。WebSocket 通信协议在 2011 年 12 月 11 日， 被 RFC 6455 - The WebSocket Protocol 定为标准。</p> <h4 id="websocket-的设计与功能"><a href="#websocket-的设计与功能" class="header-anchor">#</a> <strong>WebSocket</strong> 的设计与功能</h4> <p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其 中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为 标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p> <h4 id="websocket-协议"><a href="#websocket-协议" class="header-anchor">#</a> <strong>WebSocket</strong> 协议</h4> <p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。</p> <p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方 都可直接向对方发送报文。</p> <p>下面我们列举一下 WebSocket 协议的主要特点。</p> <h4 id="推送功能"><a href="#推送功能" class="header-anchor">#</a> 推送功能</h4> <p>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发 送数据，而不必等待客户端的请求。</p> <h4 id="减少通信量"><a href="#减少通信量" class="header-anchor">#</a> 减少通信量</h4> <p>只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相 比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息 很小，通信量也相应减少了。</p> <p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一 次“握手”(Handshaking)的步骤。</p> <p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">GET</span> <span class="token operator">/</span>chat <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token operator">:</span> server<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com
Upgrade<span class="token operator">:</span> websocket
Connection<span class="token operator">:</span> Upgrade
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Key<span class="token operator">:</span> dGhlIHNhbXBsZSBub25jZQ<span class="token operator">==</span> Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>example<span class="token punctuation">.</span>com Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token operator">:</span> chat<span class="token punctuation">,</span> superchat Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Version<span class="token operator">:</span> <span class="token number">13</span>
</code></pre></div><p>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。 Sec-WebSocket-Protocol 字段内记录使用的子协议。</p> <p>子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接 的名称。</p> <h4 id="握手-·-响应"><a href="#握手-·-响应" class="header-anchor">#</a> 握手**·**响应</h4> <p>对于之前的请求，返回状态码 101 Switching Protocols 的响应。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">101</span> Switching Protocols
Upgrade<span class="token operator">:</span> websocket
Connection<span class="token operator">:</span> Upgrade
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Accept<span class="token operator">:</span> s3pPLMBiTxaQ9kYGzzhZRbK<span class="token operator">+</span>xOo<span class="token operator">=</span> Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Protocol<span class="token operator">:</span> chat
</code></pre></div><p>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec- WebSocket-Key 的字段值生成的。</p> <p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数 据帧，而采用 WebSocket 独立的数据帧。</p> <p><img src="https://pic4.zhimg.com/80/v2-5f7581252fbc8d5162a477c3120ed909_1440w.png" alt="websocket"></p> <p>以下为调用 WebSocket API，每 50ms 发送一次数据的实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span>'ws<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>game<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">12010</span> socket<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>socket<span class="token punctuation">.</span>bufferedAmount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">getUpdateData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="期盼已久的-http-2-0"><a href="#期盼已久的-http-2-0" class="header-anchor">#</a> 期盼已久的 <strong>HTTP/2.0</strong></h2> <p>目前主流的 HTTP/1.1 标准，自 1999 年发布的 RFC2616 之后再未进 行过改订。SPDY 和 WebSocket 等技术纷纷出现，很难断言 HTTP/1.1 仍是适用于当下的 Web 的协议。</p> <p>负责互联网技术标准的 IETF(Internet Engineering Task Force，互联网 工程任务组)创立 httpbis(Hypertext Transfer Protocol Bis，http://datatracker.ietf.org/wg/httpbis/)工作组，其目标是推进下一 代 HTTP——HTTP/2.0 在 2014 年 11 月实现标准化。</p> <h3 id="http-2-0-的特点"><a href="#http-2-0-的特点" class="header-anchor">#</a> <strong>HTTP/2.0</strong> 的特点</h3> <p>HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。由于基本上 都会先通过 HTTP/1.1 与 TCP 连接，现在我们以下面的这些协议为基 础，探讨一下它们的实现方法。</p> <ul><li><strong>SPDY</strong></li> <li><strong>HTTPSpeed</strong>+<strong>Mobility</strong></li> <li><strong>Network-Friendly HTTP Upgrade</strong></li></ul> <p>HTTP Speed + Mobility 由微软公司起草，是用于改善并提高移动端 通信时的通信速度和性能的标准。它建立在 Google 公司提出的 SPDY 与 WebSocket 的基础之上。</p> <p>Network-Friendly HTTP Upgrade 主要是在移动端通信时改善 HTTP 性 能的标准。</p> <table><thead><tr><th>压缩</th> <th>SPDY、Frie ndly</th></tr></thead> <tbody><tr><td>多路复用</td> <td>SPDY</td></tr> <tr><td>TLS义务化</td> <td>Speed+Mobility</td></tr> <tr><td>协商</td> <td>Speed+Mobility，Friendly</td></tr> <tr><td>客户端拉曳(Client Pull)/服务器推送 (Server Push)</td> <td>Speed+ Mobility</td></tr> <tr><td>流量控制</td> <td>SPDY</td></tr> <tr><td>WebSocket</td> <td>Speed+Mobility</td></tr></tbody></table> <blockquote><p>注:HTTP Speed + Mobility 简写为 Speed + Mobility，Network-Friendly HTTP</p> <p>Upgrade 简写为 Friendly。</p></blockquote> <h2 id="了解http0-9-http3"><a href="#了解http0-9-http3" class="header-anchor">#</a> 了解HTTP0.9~HTTP3</h2> <p>在 30 多年的历史中，HTTP 协议本身有比较大的发展，同时，还有一些重大的变动也在酝酿之中。这些演化使得这个协议的表现力更强，性能更好，更能满足日新月异的应用需求。本文就来回顾和展望一下 HTTP 的历史和未来。</p> <p>下面我会介绍：</p> <ul><li>HTTP/0.9</li> <li>HTTP/1.0</li> <li>HTTP/1.1</li> <li>HTTP/2</li> <li>HTTP/3</li></ul> <h3 id="http-0-9"><a href="#http-0-9" class="header-anchor">#</a> HTTP 0.9</h3> <p>HTTP0.9诞生于1991年，是HTTP协议的最初版，构建十分简单：</p> <ul><li>请求端只支持GET请求</li> <li>相应端只能返回HTML文件数据</li></ul> <p>请求：</p> <div class="language-http extra-class"><pre class="language-http"><code>GET /index.html
</code></pre></div><p>返回：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    Hello World
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>画图：后面补</p></blockquote> <p>可以看到，HTTP/0.9 只能发送 GET 请求，且每一个请求都单独创建一个 TCP 连接，响应端只能返回 HTML 格式的数据，响应完成之后 TCP 请求断开。</p> <p>这样的请求方式虽然能够满足当时的使用需求，但也还是暴露出了一些问题。</p> <p>HTTP/0.9 痛点：</p> <ul><li>请求方式唯一，返回格式唯一</li> <li>TCP 连接无法复用</li></ul> <h3 id="http1-0"><a href="#http1-0" class="header-anchor">#</a> HTTP1.0</h3> <p>HTTP/1.0 诞生于 <a href="https://www.w3.org/Protocols/HTTP/1.0/spec.html" target="_blank" rel="noopener noreferrer">1996<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 年，它在 HTTP/0.9 的基础上，增加了 HTTP 头部字段，极大扩展了 HTTP 的使用场景。这个版本的 HTTP 不仅可以传输文字，还能传输图像、视频、二进制文件，为互联网的迅速发展奠定了坚实的基础。</p> <p>核心特点如下：</p> <ul><li>请求端增加 HTTP 协议版本，响应端增加状态码。</li> <li>请求方法增加 POST、HEAD。</li> <li>请求端和响应端增加头部字段。
<ul><li>Content-Type 让响应数据不只限于超文本。</li> <li>Expires、Last-Modified 缓存头。</li> <li>Authorization 身份认证。</li> <li>Connection: keep-alive 支持长连接，但非标准。</li></ul></li></ul> <p>请求：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /mypage.html HTTP/1.0</span>
<span class="token header-name keyword">User-Agent:</span> NCSA_Mosaic/2.0 (Windows 3.1)
</code></pre></div><p>响应头：</p> <div class="language-http extra-class"><pre class="language-http"><code>200 OK
<span class="token header-name keyword">Date:</span> Tue, 15 Nov 1994 08:12:31 GMT
<span class="token header-name keyword">Server:</span> CERN/3.0 libwww/2.17
<span class="token header-name keyword">Content-Type:</span> text/html
</code></pre></div><p>相应实体：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    Hello World
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>画图：请求过程图。后期补充</p></blockquote> <p>通过上面的过程我们可以看到，HTTP1.0拓展了请求方法和响应状态码，并且支持定义HTTP头部字段，通过<code>Content-Type</code>配置，我们就能传输任何数据类型了。通过，HTTP1.0任然是一个请求对一个TCP链接，不能形成复用。</p> <p>HTTP/1.0 痛点：</p> <ul><li>TCP 连接无法复用。</li> <li>HTTP 队头阻塞，一个 HTTP 请求响应结束之后，才能发起下一个 HTTP 请求。</li> <li>一台服务器只能提供一个 HTTP 服务。</li></ul> <h3 id="http1-1"><a href="#http1-1" class="header-anchor">#</a> HTTP1.1</h3> <p>HTTP1.1诞生于1999年，它进一步完善了HTTP协议，一直到了20年后的今天，任然是使用最广的HTTP版本。</p> <p>HTTP1.1核心特点如下：</p> <ul><li>持久连接。
<ul><li>HTTP/1.1 默认开启持久连接，在 TCP 连接建立后不立即关闭，让多个 HTTP 请求得以复用。</li></ul></li> <li>管线化技术。
<ul><li>HTTP/1.1 中，多个 HTTP 请求不用排队发送，可以批量发送，这就解决了 HTTP 队头阻塞问题。但批量发送的 HTTP 请求，必须按照发送的顺序返回响应，相当于问题解决了一半，仍然不是最佳体验。</li></ul></li> <li>支持响应分块。
<ul><li>HTTP/1.1 实现了流式渲染，响应端可以不用一次返回所有数据，可以将数据拆分成多个模块，产生一块数据，就发送一块数据，这样客户端就可以同步对数据进行处理，减少响应延迟，降低白屏时间。</li> <li>Bigpipe 的实现就是基于这个特性，具体是通过定义 <code>Transfer-Encoding</code> 头来实现的。</li></ul></li> <li>增加 Host 头。
<ul><li>HTTP/1.1 实现了虚拟主机技术，将一台服务器分成若干个主机，这样就可以在一台服务器上部署多个网站了。</li> <li>通过配置 Host 的域名和端口号，即可支持多个 HTTP 服务： <code>Host: &lt;domain&gt;:&lt;port&gt;</code></li></ul></li> <li>其他扩展。
<ul><li>增加 Cache-Control、E-Tag 缓存头。</li> <li>增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 请求方法。</li></ul></li></ul> <p>请求头：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /en-US/docs/Glossary/Simple_header HTTP/1.1</span>
<span class="token header-name keyword">Host:</span> developer.mozilla.org
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
<span class="token header-name keyword">Accept-Language:</span> en-US,en;q=0.5
<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate, br
<span class="token header-name keyword">Referer:</span> https://developer.mozilla.org/en-US/docs/Glossary/Simple_header
</code></pre></div><p>响应头：</p> <div class="language-http extra-class"><pre class="language-http"><code>200 OK
<span class="token header-name keyword">Connection:</span> Keep-Alive
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Date:</span> Wed, 20 Jul 2016 10:55:30 GMT
<span class="token header-name keyword">Etag:</span> &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;
<span class="token header-name keyword">Keep-Alive:</span> timeout=5, max=1000
<span class="token header-name keyword">Last-Modified:</span> Tue, 19 Jul 2016 00:59:33 GMT
<span class="token header-name keyword">Server:</span> Apache
<span class="token header-name keyword">Transfer-Encoding:</span> chunked
<span class="token header-name keyword">Vary:</span> Cookie, Accept-Encoding

&lt;html&gt;
  &lt;body&gt;
    Hello World
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>响应实体：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    Hello World
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>图片后期补</p> <p>可以看到，HTTP/1.1 可以并行发起多个请求，并且也能复用同一个 TCP 连接，传输效率得到了提升。但响应端只能按照发送的顺序进行返回，为此很多浏览器会为每个域名至多打开 6 个连接，用增加队列的方式减少 HTTP 队头阻塞。</p> <p>HTTP/1.1 痛点：</p> <ul><li>HTTP 队头阻塞没有彻底解决，响应端必须按照 HTTP 的发送顺序进行返回，如果排序靠前的响应特别耗时，则会阻塞排序靠后的所有响应。</li></ul> <h3 id="http2"><a href="#http2" class="header-anchor">#</a> HTTP2</h3> <p>HTTP/2 诞生于 <a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener noreferrer">2015<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 年，它的最大的特点是 All in 二进制，基于二进制的特性，对 HTTP 传输效率进行了深度优化。</p> <p>HTTP/2 将一个 HTTP 请求划分为 3 个部分：</p> <ul><li>帧：一段二进制数据，是 HTTP/2 传输的最小单位。</li> <li>消息：一个请求或响应对应的一个或多个帧。</li> <li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li></ul> <blockquote><p>TODO：多路复用请求图，后期补</p></blockquote> <p>图中可以看到，<strong>一个 TCP 连接上有多个数据流，一个数据流承载着双向消息，一条消息包含了多个帧，每个帧都有唯一的标识，指向所在的数据流</strong>，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装，这样就实现了数据传输。</p> <p>HTTP/2 核心特点如下：</p> <ul><li>请求优先级
<ul><li>多个 HTTP 请求同时发送时，会产生多个数据流，数据流中有一个优先级的标识，服务器端可以根据这个标识来决定响应的优先顺序。</li></ul></li> <li>多路复用
<ul><li>TCP 传输时，不用按照 HTTP 的发送顺序进行响应，可以交错发送，接收端根据帧首部的标识符，就能找到对应的流，进而重新组合得到最终数据。</li></ul></li> <li>服务器端推送
<ul><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，并缓存到客户端中，以避免二次请求。</li> <li>HTTP/1.1 中请求一个页面时，浏览器会先发送一个 HTTP 请求，然后得到响应的 HTML 内容并开始解析，如果发现有 <code>&lt;script src=&quot;xxxx.js&quot;&gt;</code> 标签，则会再次发起 HTTP 请求获取对应的 JS 内容。而 HTTP/2 可以在返回 HTML 的同时，将需要用到的 JS、CSS 等内容一并返回给客户端，当浏览器解析到对应标签时，也就不需要再次发起请求了。</li></ul></li> <li>头部压缩
<ul><li>HTTP/1.1 的头部字段包含大量信息，而且每次请求都得带上，占用了大量的字节。</li> <li>HTTP/2.0 中通信双方各自缓存一份头部字段表，如：把 <code>Content-Type:text/html</code> 存入索引表中，后续如果要用到这个头，只需要发送对应的索引号就可以了。</li></ul></li></ul> <blockquote><p>TODO：请求图，后期补</p></blockquote> <p>可以看到，在 HTTP/2 中发送请求时，既不需要排队发送，也不需要排队返回，彻底解决了 HTTP 队头阻塞问题。对于头部信息，资源缓存等痛点也进行了优化，似乎已经是一种很完美的方案了。</p> <p>HTTP/2 在 HTTP + TCP 的架构上已经优化到了极致，如果要想继续优化，那就只能从这个架构入手了。</p> <p>首先需要优化的是 TCP，因为 TCP 核心是保证传输层的可靠性，传输效率其实并不好。</p> <ul><li>TCP 也存在队头阻塞，TCP 在传输时使用序列号标识数据的顺序，一旦某个数据丢失，后面的数据需要等待这个数据重传后才能进行下一步处理。</li> <li>TCP 每一次建立都需要三次握手，释放连接需要四次挥手，无形中增加了传输时长。</li> <li>TCP 存在拥塞控制，内置了慢启动，拥塞避免等算法，传输效率并不稳定。</li></ul> <p>如果要解决这些问题，就需要替换掉 TCP，而这也是 HTTP/3 的解决思路，我们接着往下看。</p> <h3 id="http3"><a href="#http3" class="header-anchor">#</a> HTTP3</h3> <p>它的主要特点是对传输层进行了优化，<strong>使用 QUIC 替换 TCP</strong>，彻底规避了 TCP 传输的效率问题。</p> <p>**QUIC 由 Google 提出的基于 UDP 进行多路复用的传输协议。**QUIC 没有连接的概念，不需要三次握手，在应用程序层面，实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性。在设备支持层面，只需要客户端和服务端的应用程序支持 QUIC 协议即可，无操作系统和中间设备的限制。</p> <p>HTTP3的核心特点如下：</p> <ul><li><p>传输层连接更快</p> <ul><li>HTTP/3 基于 QUIC 协议，可以实现 0-RTT 建立连接，而 TCP 需要 3-RTT 才能建立连接。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/942057ba62f4421e8a504e93b4470ebb~tplv-k3u1fbpfcp-zoom-1.image?imageslim" alt="img"></p></li> <li><p>传输层多路复用</p> <ul><li>HTTP/3 传输层使用 QUIC 协议，数据在传输时会被拆分成了多个 packet 包，每一个 packet 包都可以独立、交错发送，不用按顺序发送，也就避免了 TCP 队头阻塞。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc73576322644c91a5ec801a9ede9f3f~tplv-k3u1fbpfcp-zoom-1.image?imageslim" alt="img"></p></li></ul> <p>上图中的 Stream 之间相互独立，如果 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4 正常读取。</p> <ul><li><p>改进的拥塞控制</p> <ul><li><p><strong>单调递增的 Packet Number</strong>。在 TCP 中，每一个数据包都有一个序列号标识（seq），如果接收端超时没有收到，就会要求重发标识为 seq 的包，如果这时超时的包也接收到了，则无法区分哪个是超时的包，哪个是重传的包。QUIC 中的每一个包的标识（Packet Number）都是单调递增的，重传的 Packet Number 一定大于超时的 Packet Number，这样就能区分开了。</p></li> <li><p><strong>不允许 Reneging</strong>。在 TCP 中，如果接收方内存不够或 Buffer 溢出，则可能会把已接收的包丢弃（Reneging），这种行为对数据重传产生了很大的干扰，在 QUIC 中是明确禁止的。在 QUIC 中，一个包只要被确认，就一定是被正确接收了。</p></li> <li><p><strong>更多的 ACK 块</strong>。一般来说，接收方收到发送方的消息后都会发送一个 ACK 标识，表示收到了数据。但每收到一个数据就发送一个 ACK 效率太低了，通常是收到多个数据后再统一回复 ACK。TCP 中每收到 3 个数据包就要返回一个 ACK，而 QUIC 最多可以收到 256 个包之后，才返回 ACK。在丢包率比较严重的网络下，更多的 ACK 块可以减少重传量，提升网络效率。</p></li> <li><p><strong>Ack Delay</strong>。TCP 计算 RTT 时没有考虑接收方处理数据的延迟，如下图所示，这段延迟即 ACK Delay。QUIC 考虑了这段延迟，使得 RTT 的计算更加准确。</p></li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/201a0c1019c34366b5a387bce7ce4450~tplv-k3u1fbpfcp-zoom-1.image?imageslim" alt="img"></p></li> <li><p>优化的流量控制</p> <ul><li>TCP 通过滑动窗口来控制流量，如果某一个包丢失了，滑动窗口并不能跨过丢失的包继续滑动，而是会卡在丢失的位置，等待数据重传后，才能继续滑动。</li> <li>QUIC 流量控制的核心是：<strong>不能建立太多的连接，以免响应端处理不过来；不能让某一个连接占用大量的资源，让其他连接没有资源可用</strong>。为此 QUIC 流量控制分为 2 个级别：连接级别（Connection Level）和 Stream 级别（Stream Level）。
<ul><li>Stream 级别的流量控制中，<code>接收窗口 = 最大接收窗口- 已接收数据</code>。</li> <li>Connection 级别的流量控制中，<code>接收窗口 = Stream1接收窗口 + Stream2接收窗口 + ... + StreamN接收窗口</code>。</li></ul></li></ul></li> <li><p>加密认证的报文</p> <ul><li>TCP 头部没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改，注入和窃听。</li> <li>QUIC 中报文都是经过加密和认证的，在传输过程中保证了数据的安全。</li></ul></li> <li><p>连接迁移</p> <ul><li>TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这四者中一旦有一项发生改变，这个连接也就不能用了。如果我们从 5G 网络切换到 WiFi 网络，IP 地址就会改变，这个时候 TCP 连接也自然断掉了。</li> <li>QUIC 使用客户端生成的 64 位 ID 来表示一条连接，只要 ID 不变，这条连接也就一直维持着，不会中断。</li></ul></li> <li><p>前向纠错机制</p> <p>QUIC 中发送数据时，除了发送本身的数据包，还会发送验证包，以减少数据丢失导致的重传。</p> <p>例如：</p> <ul><li>发送端需要发送三个包，QUIC 在传输时会计算出这三个包的异或值，并单独发出一个校验包，也就是总共发出了四个包。</li> <li>如果某一个包（非校验包）传输时丢失了，则可以通过另外三个包计算出丢失数据包的内容。</li> <li>当然这种技术只能用在丢失一个包的情况下，如果丢失了多个包，就只能进行重传了。</li></ul></li></ul> <p>可以看出，QUIC 丢掉了 TCP 的包袱，基于 UDP，实现了一个安全高效可靠的 HTTP 通信协议。凭借着 0-RTT 建立连接、传输层多路复用、连接迁移、改进的拥塞控制、流量控制等特性，QUIC 在绝大多数场景下获得了比 HTTP/2 更好的效果，HTTP/3 真是未来可期。</p> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <ul><li>HTTP/0.9 实现基本请求响应。</li> <li>HTTP/1.0 增加 HTTP 头，丰富传输资源类型，奠定互联网发展基础。</li> <li>HTTP/1.1 增加持久连接、管线化、响应分块，提升了 HTTP 传输效率。</li> <li>HTTP/2 采用二进制传输格式，通过 HTTP 多路复用、头部压缩、服务器端推送，将传输效率在 HTTP + TCP 架构上发挥到了极致。</li> <li>HTTP/3 将传输层替换为 QUIC，通过改进的拥塞控制、流量控制、0-RTT 建连、传输层多路复用、连接迁移等特性，进一步提升了 HTTP 传输效率。</li></ul> <p>可以看到，从 HTTP/1.1 开始，HTTP 的发展方向就是：不断地提升传输效率。期待未来的 HTTP 能够给我们带来更加快速的传输体验。</p> <h2 id="媒体类型-mime"><a href="#媒体类型-mime" class="header-anchor">#</a> 媒体类型（MIME）</h2> <p>因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型(MIME type)的数据格式标签。最初设计 MIME (Multipurpose Internet Mail Extension，多用途因特网邮件扩展)是为了解决在不同 的电子邮件系统之间搬移报文时存在的问题。MIME 在电子邮件系统中工作得非常好，因此 HTTP 也采纳了它，用它来描述并标记多媒体内容。</p> <p>Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型。当 Web 浏览器从服务器中取回一个对象时，会去查看相关的 MIME 类型，看看它是否知道 应该如何处理这个对象。大多数浏览器都可以处理数百种常见的对象类型:显示图 片文件、解析并格式化 HTML 文件、通过计算机声卡播放音频文件，或者运行外部插件软件来处理特殊格式的数据。</p> <p>![image-20210202144123242](/Users/smallzip/Library/Application Support/typora-user-images/image-20210202144123242.png)</p> <p>上图是与数据内容一同回送的 MIME 类型；</p> <p>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。</p> <ul><li><p>HTML 格式的文本文档由 text/html 类型来标记。</p></li> <li><p>普通的 ASCII 文本文档由 text/plain 类型来标记。</p></li> <li><p>JPEG 格式的图片为 image/jpeg 类型。</p></li> <li><p>GIF 格式的图片为 image/gif 类型。</p></li> <li><p>Apple 的 QuickTime 电影为 video/quicktime 类型。</p></li> <li><p>微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。</p> <p>常见的 MIME 类型有数百个，实验性或用途有限的 MIME 类型则更多。参加《HTTP权威指南》附录 D 提 供了一个非常完整的 MIME 类型列表。</p></li></ul> <h2 id="udp协议"><a href="#udp协议" class="header-anchor">#</a> UDP协议</h2> <p>**UDP协议全称用户数据报协议，**在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p> <p>udp有一下特点：</p> <h3 id="_1-面向无连接"><a href="#_1-面向无连接" class="header-anchor">#</a> 1. 面向无连接</h3> <p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p> <p>具体来说就是：</p> <ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li> <li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul> <h3 id="有单播-多播-广播的功能"><a href="#有单播-多播-广播的功能" class="header-anchor">#</a> 有单播，多播，广播的功能</h3> <p>udp不仅支持一对一的传输方式，同样是支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。</p> <p>![image-20210202235249187](/Users/smallzip/Library/Application Support/typora-user-images/image-20210202235249187.png)</p> <h4 id="udp广播"><a href="#udp广播" class="header-anchor">#</a> UDP广播</h4> <p>广播UDP与单播UDP的区别就是IP地址不同，广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：<strong>本地广播信息是不会被路由器转发</strong>。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。</p> <p>广播地址通常用于在网络游戏中处于同一本地网络的玩家之间交流状态信息等。</p> <p>其实广播顾名思义，就是想局域网内所有的人说话，<strong>但是广播还是要指明接收者的端口号的</strong>，因为不可能接受者的所有端口都来收听广播。</p> <h4 id="udp多播"><a href="#udp多播" class="header-anchor">#</a> UDP多播</h4> <p>多播，也称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。</p> <p>在广域网上广播的时候，其中的交换机和路由器只向需要获取数据的主机复制并转发数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择地复制并传输数据，将数据仅仅传输给组内的主机。多播的这种功能，可以一次将数据发送到多个主机，又能保证不影响其他不需要（未加入组）的主机的其他通 信。</p> <p>相对于传统的一对一的单播，多播具有如下的优点：</p> <p>1、具有同种业务的主机加入同一数据流，共享同一通道，节省了带宽和服务器的优点，具有广播的优点而又没有广播所需要的带宽。</p> <p>2、服务器的总带宽不受客户端带宽的限制。由于组播协议由接收者的需求来确定是否进行数据流的转发，所以服务器端的带宽是常量，与客户端的数量无关。</p> <p>3、与单播一样，多播是允许在广域网即Internet上进行传输的，而广播仅仅在同一局域网上才能进行。</p> <p>组播的缺点：</p> <p>1、多播与单播相比没有纠错机制，当发生错误的时候难以弥补，但是可以在应用层来实现此种功能。</p> <p>2、多播的网络支持存在缺陷，需要路由器及网络协议栈的支持。</p> <p>3、多播的应用主要有网上视频、网上会议等。</p> <h4 id="udp广播和单播比较"><a href="#udp广播和单播比较" class="header-anchor">#</a> UDP广播和单播比较</h4> <p>广播和单播的处理过程是不同的，单播的数据只是收发数据的特定主机进行处理，而广播的数据整个局域网都进行处理。</p> <p>例如在一个以太网上有3个主机，主机的配置如下</p> <p>主机的配置情况：</p> <table><thead><tr><th>主 机</th> <th><strong>A</strong></th> <th><strong>B</strong></th> <th><strong>C</strong></th></tr></thead> <tbody><tr><td>IP地址</td> <td>192.168.1.150</td> <td>192.168.1.151</td> <td>192.168.1.158</td></tr> <tr><td>MAC地址</td> <td>00:00:00:00:00:01</td> <td>00:00:00:00:00:02</td> <td>00:00:00:00:00:03</td></tr></tbody></table> <p>​		单播流程：主机A向主机B发送UDP数据报，发送的目的IP为192.168.1.151，端口为 80，目的MAC地址为00:00:00:00:00:02。此数据经过UDP层、IP层，到达数据链路层，数据在整个以太网上传播，在此层中其他主机会 判断目的MAC地址。主机C的MAC地址为00:00:00:00:00:03，与目的MAC地址00:00:00:00:00:02不匹配，数据链路层 不会进行处理，直接丢弃此数据。</p> <p>主机B的MAC地址为00:00:00:00:00:02，与目的MAC地址00:00:00:00:00:02一致，此数据会经过IP层、UDP层，到达接收数据的应用程序。</p> <p>广播的流程：主机A向整个网络发送广播数据，发送的目的IP为192.168.1.255，端口为 80，目的MAC地址为FF:FF:FF:FF:FF:FF。此数据经过UDP层、IP层，到达数据链路层，数据在整个以太网上传播，在此层中其他主机会 判断目的MAC地址。由于目的MAC地址为FF:FF:FF:FF:FF:FF，主机C和主机B会忽略MAC地址的比较（当然，如果协议栈不支持广播，则 仍然比较MAC地址），处理接收到的数据。</p> <p>主机B和主机C的处理过程一致，此数据会经过IP层、UDP层，到达接收数据的应用程序。</p> <h3 id="udp是面向报文的"><a href="#udp是面向报文的" class="header-anchor">#</a> UDP是面向报文的</h3> <p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p> <h3 id="不可靠性"><a href="#不可靠性" class="header-anchor">#</a> 不可靠性</h3> <p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p> <p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p> <p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/2/24/1691f177ce522344?imageslim" alt="img"></p> <p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p> <h3 id="头部开销小-传输数据报文时很高效"><a href="#头部开销小-传输数据报文时很高效" class="header-anchor">#</a> 头部开销小，传输数据报文时很高效</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/2/24/1691f340e82df2d5?imageslim" alt="img"></p> <p>UDP头部包含了以下几个数据：</p> <ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li> <li>整个数据报文的长度</li> <li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul> <p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p> <h2 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h2> <p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。</p> <p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p> <h3 id="tcp链接过程"><a href="#tcp链接过程" class="header-anchor">#</a> TCP链接过程</h3> <p>TCP链接就是三次握手</p> <p><img src="https://user-gold-cdn.xitu.io/2019/2/24/1691fa18ef700560?imageslim" alt="img"></p> <p><strong>第一次握手</strong></p> <p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p> <p><strong>第二次握手</strong></p> <p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p> <p><strong>第三次握手</strong></p> <p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p> <p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/2/24/1691f1390798a9a4?imageslim" alt="img"></p> <h3 id="tcp断开链接"><a href="#tcp断开链接" class="header-anchor">#</a> TCP断开链接</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/2/24/1691fad9308022c9?imageslim" alt="img"></p> <p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p> <p><strong>第一次握手</strong></p> <p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p> <p><strong>第二次握手</strong></p> <p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p> <p><strong>第三次握手</strong></p> <p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p> <p><strong>第四次握手</strong></p> <p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p> <h3 id="tcp协议的特点"><a href="#tcp协议的特点" class="header-anchor">#</a> TCP协议的特点</h3> <ul><li>面向连接</li></ul> <p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p> <ul><li>仅支持单播传输</li></ul> <p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p> <ul><li>面向字节流</li></ul> <p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p> <ul><li>可靠传输</li></ul> <p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p> <ul><li>提供拥塞控制</li></ul> <p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p> <ul><li>TCP提供全双工通信</li></ul> <p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p> <h3 id="tcp和udp比较"><a href="#tcp和udp比较" class="header-anchor">#</a> TCP和UDP比较</h3> <h3 id="_1-对比"><a href="#_1-对比" class="header-anchor">#</a> 1.对比</h3> <table><thead><tr><th></th> <th>UDP</th> <th>TCP</th></tr></thead> <tbody><tr><td>是否连接</td> <td>无连接</td> <td>面向连接</td></tr> <tr><td>是否可靠</td> <td>不可靠传输，不使用流量控制和拥塞控制</td> <td>可靠传输，使用流量控制和拥塞控制</td></tr> <tr><td>连接对象个数</td> <td>支持一对一，一对多，多对一和多对多交互通信</td> <td>只能是一对一通信</td></tr> <tr><td>传输方式</td> <td>面向报文</td> <td>面向字节流</td></tr> <tr><td>首部开销</td> <td>首部开销小，仅8字节</td> <td>首部最小20字节，最大60字节</td></tr> <tr><td>适用场景</td> <td>适用于实时应用（IP电话、视频会议、直播等）</td> <td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table> <h3 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h3> <ul><li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li> <li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li> <li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/27/2021, 11:15:29 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/javascript设计模式.html" class="prev">
        javascript设计模式
      </a></span> <span class="next"><a href="/Flutter学习笔记.html">
        Flutter学习笔记
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.066415a4.js" defer></script><script src="/assets/js/2.88013ddf.js" defer></script><script src="/assets/js/38.42798cb0.js" defer></script>
  </body>
</html>
