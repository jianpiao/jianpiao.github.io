(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{414:function(t,_,v){"use strict";v.r(_);var a=v(45),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"网络基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络基础知识"}},[t._v("#")]),t._v(" 网络基础知识")]),t._v(" "),v("p",[t._v("网络基础知识包括常见的OSI七层网络模型，或者TCP/IP协议族四层网络模型。")]),t._v(" "),v("h2",{attrs:{id:"基础概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),v("p",[v("strong",[t._v("OIS七层")]),t._v("：应用层、表达层、会话层、传输层、网络层、链路层、物理层。")]),t._v(" "),v("p",[v("strong",[t._v("TCP/IP协议")]),t._v("：应用层、传输层、网络层、数据链路层。")]),t._v(" "),v("p",[t._v("下面讲解一下基于TCP/IP的协议族的内容。")]),t._v(" "),v("h2",{attrs:{id:"应用层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[t._v("#")]),t._v(" 应用层")]),t._v(" "),v("p",[t._v("我们常见的HTTP就是属于应用层。")]),t._v(" "),v("p",[t._v("应用层决定了向用户提供应该服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，"),v("code",[t._v("HTTP（超文件传输协议）")]),t._v(","),v("code",[t._v("FTP（FileTransfer Protocol，文件传输协议）")]),t._v("和"),v("code",[t._v("DNS（Domain Name System，域名系统）")]),t._v("服务等等。")]),t._v(" "),v("h3",{attrs:{id:"http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),v("p",[t._v("http超文本传输协议，基于TCP连接进行报文传输，基于请求响应模式的无状态协议。")]),t._v(" "),v("p",[t._v("http请求报文格式：请求行，请求头header，包含数据的body。http响应报文：状态行，响应头header，包含数据的body")]),t._v(" "),v("p",[t._v("常见的http方法：get，post，put，delete，options。常见的响应码和描述符：1xx信息提示，2xx成功，3xx重定向，4xx客户端错误，5xx服务器错误")]),t._v(" "),v("p",[t._v("一次http请求过程：解析主机名，dns查询ip，获取端口号，建立tcp连接。发送请求报文，返回响应报文，关闭连接。http性能优化无非就在这几个环节。 DNS查询，TCP连接建立耗时，TCP慢启动和拥塞控制。")]),t._v(" "),v("p",[t._v("http协议可以升级成为websocket协议，http请求的时候，通过请求头部设置"),v("code",[t._v("Connection: Upgrade")]),t._v(" "),v("code",[t._v("Upgrader: websocket")]),t._v("申请协议升级， 服务器返回101响应表示协议转换成功。后续在该tcp连接就可以进行全双工的通信，传输的是websocket的报文。")]),t._v(" "),v("h3",{attrs:{id:"https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),v("p",[t._v("https本质是协商生成一对对称密钥然后对http报文进行加密传输的过程。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-6653dcc0e9d6602c8df75ea1648a5e39_720w.png",alt:"image-20210219195035977"}})]),t._v(" "),v("h4",{attrs:{id:"https通信过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https通信过程"}},[t._v("#")]),t._v(" HTTPS通信过程")]),t._v(" "),v("p",[t._v("https需要进行9次握手的过程。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-8aa22078aa24c72428f8c36828f7748f_720w.png",alt:"image-20210219195120307"}})]),t._v(" "),v("p",[v("strong",[t._v("步骤 1")]),t._v(": 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包 含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所 使用的加密算法及密钥长度等)。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 2")]),t._v(": 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。")]),t._v(" "),v("p",[v("strong",[t._v("步骤  3")]),t._v(": 之后服务器发送 Certificate 报文。报文中包含公开密钥证 书。")]),t._v(" "),v("p",[v("strong",[t._v("步骤  4")]),t._v(": 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 5")]),t._v(": SSL 第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 6")]),t._v(": 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 7")]),t._v(": 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 8")]),t._v(": 服务器同样发送 Change Cipher Spec 报文。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 9")]),t._v(": 服务器同样发送 Finished 报文。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 10")]),t._v(": 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接 就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 11")]),t._v(": 应用层协议通信，即发送 HTTP 响应。")]),t._v(" "),v("p",[v("strong",[t._v("步骤 12")]),t._v(": 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。")]),t._v(" "),v("h3",{attrs:{id:"http请求影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http请求影响"}},[t._v("#")]),t._v(" HTTP请求影响")]),t._v(" "),v("p",[t._v("影响一个HTTP网络请求的因素主要有两个：带宽和延迟。")]),t._v(" "),v("p",[t._v("详细介绍看http的发展史：了解HTTP")]),t._v(" "),v("h2",{attrs:{id:"传输层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[t._v("#")]),t._v(" 传输层")]),t._v(" "),v("p",[t._v("IP层为上层的数据传输，提供了封装，分片，重组，路由选择等底层传输细节功能，使上层可以专注于数据本身。下面我们来看看传输层两个重要的协议。")]),t._v(" "),v("ol",[v("li",[t._v("UDP -- 用户数据报协议")]),t._v(" "),v("li",[t._v("TCP -- 传输控制协议")])]),t._v(" "),v("h3",{attrs:{id:"什么是udp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是udp协议"}},[t._v("#")]),t._v(" 什么是UDP协议？")]),t._v(" "),v("p",[t._v("UDP协议是一个比较简单的协议。它为上层提供无连接不可靠无顺序的数据报服务。UDP数据报结构：16位源端口号+16位目的端口号+16位UDP长度+ 16位UDP检验和+数据部分。在IP数据报的基础上，它增加了端口部分，同时增加IP内容部分（UDP数据报）的检验和。检验和方法与IP一样。UDP数据报按16位对齐。 通过netstat -p udp可以查看运行接收udp数据报到的服务器和收发情况。当系统接收数据报的速率大于处理速率时就可能产生ICMP源站抑制差错。 DNS域名系统一般会用UDP实现。")]),t._v(" "),v("h3",{attrs:{id:"什么是dns域名系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是dns域名系统"}},[t._v("#")]),t._v(" 什么是DNS域名系统？")]),t._v(" "),v("p",[t._v("DNS域名系统本质是用于TCP/IP应用程序的分布式数据库，提供主机名和IP地址的转换和有关电子邮件的选路信息。从应用角度，对DNS的访问是通过一个地址解析器完成， 在Unix主机，主要提供两个库函数gethostbyname，gethostbyaddr。DNS的名字空间和Unix文件系统相似，顶级域如.com，.edu，再划分二级域，可以继续划分。每一个区域的 授权机构被委派后，就由其负责向该区域提供多个名字服务器。DNS有特定的查询和响应报文格式，可以通过UDP或TCP传输。当我们购买一台云主机时获得一个公网地址，再注册一个域名， 这时候我们就需要让域名解析到我们对应的服务器IP上。这个过程可以理解为向名字服务器添加一条资源记录，当其他设备访问域名时就会先通过区域的DNS服务器查询， 如果查不到则会一级一级往上查询，最终就能查到域名对应的IP地址。")]),t._v(" "),v("h3",{attrs:{id:"什么是tcp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是tcp协议"}},[t._v("#")]),t._v(" 什么是TCP协议？")]),t._v(" "),v("p",[t._v("TCP传输控制协议，同样，我们先看定义：TCP提供面向连接可靠的字节流服务。面向连接意味着两个使用TCP应用交换数据时需要先建立连接，并维护连接的状态信息。 TCP提供可靠性，对比我们前面说的IP协议，UDP协议的不可靠（不保证数据报到达丢了就丢了），TCP会有一系列策略，其中很容易想到的就是确认和重发策略。 TCP提供的是字节流服务而不是数据报服务。TCP底层还是IP的数据报，但不同于UDP的独立数据报处理，TCP在同一个连接的数据的是连续的，只是传输过程的IP数据报是独立。 TCP接收端会重组和去重成字节流提交给上层应用。")]),t._v(" "),v("h3",{attrs:{id:"tcp有什么策略提供可靠性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp有什么策略提供可靠性"}},[t._v("#")]),t._v(" TCP有什么策略提供可靠性")]),t._v(" "),v("p",[t._v("数据分割：应用数据会被分割成TCP认为最适合发送的报文段传递给IP层。")]),t._v(" "),v("p",[t._v("确认与重传：TCP发出发出一个报文段后，会启动一个定时器，并等待目的端发回的确认。如果超时，则会重发这个报文段。")]),t._v(" "),v("p",[t._v("延迟确认：TCP接收端收到报文段后并不是立刻发送确认，而是启动定时器略微推迟，尽可能由接收端返回数据时捎带上ACK，提高网络利用效率。")]),t._v(" "),v("p",[t._v("数据检验：TCP会检验报文段的首部和数据，如果检验失败，则丢弃该数据报并等待发送端超时重发。")]),t._v(" "),v("p",[t._v("重排去重：TCP会对收到的数据进行重新排序，并丢弃重复的数据，将收到的数据以正确的顺序提交给应用层。")]),t._v(" "),v("p",[t._v("流量控制：TCP连接是全双工，有读，写两个固定大小的缓冲区。通过滑动窗口协议，TCP接收端会通告接收窗口大小，避免发送端发送过快导致接收端缓冲区溢出。")]),t._v(" "),v("h3",{attrs:{id:"tcp数据报结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp数据报结构"}},[t._v("#")]),t._v(" TCP数据报结构")]),t._v(" "),v("p",[t._v("16位源端口号+16位目的端口号。一条连接可以由网络四元组（源IP，目的IP，源端口，目的端口）确定。")]),t._v(" "),v("p",[t._v("32位序号。建立一个连接时，系统会为该连接分配一个初始序号ISN。不同方向有各自的初始序号。后续的数据按字节计数。SYN和FIN占用一个序号。")]),t._v(" "),v("p",[t._v("32位确认号。最近一个接收成功的序号+1，表示期望接收的下一个序号。ACK标志设置为1时，该字段才有效。")]),t._v(" "),v("p",[t._v("4位首部长度+保留6位+6位标志位+16位窗口大小。首部长度同IP首部长度一样，单位都是4字节。标志位URG表示TCP进入紧急模式，ACK表示确认序号有效， PSH表示正常数据，RST表示复位连接，SYN表示这是一个同步序号用来建立连接，FIN表示发送端完成发送任务。16位窗口大小单位为字节，表示接收端期望接收 的字节。")]),t._v(" "),v("p",[t._v("16位检验和+16位紧急指针。检验和覆盖整个TCP首部和数据。当URG标志为1则表明进入紧急模式。紧急指针是一个正偏移量，和序号段中的值相加表示紧急数据最后一个字节的序号。")]),t._v(" "),v("p",[t._v("可选项。常见的可选项为最长报文段大小MSS。在连接通信的第一个报文段中指明这个选项，指明本端能接收的最大长度报文段。发送端将不发送超过该大小的报文段，通常是为了避免分段。")]),t._v(" "),v("h3",{attrs:{id:"tcp如何建立连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp如何建立连接"}},[t._v("#")]),t._v(" TCP如何建立连接")]),t._v(" "),v("p",[t._v("TCP连接最重要的就是三次握手的过程。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("请求端执行主动打开，发送一个SYN分组，带上初始序号，窗口大小，最大分段大小MSS，这时发送端进入SYN_SENT状态。")])]),t._v(" "),v("li",[v("p",[t._v("响应端收到SYN后执行被动打开，发回一个SYN分组，带上响应端的初始序号，窗口大小，最大分段大小MSS。同时设置了ACK位置，确认序号为请求端初始序号+1，cpdump用相对序号1表示。此时响应端进入SYN_RCVD状态。")])]),t._v(" "),v("li",[v("p",[t._v("请求端收到ACK进入ESTABLISHED状态，同时对响应端发送的SYN，发回一个ACK响应。当响应端收到ACK则也进入ESTABLISHED状态，连接就算建立了。")])])]),t._v(" "),v("h4",{attrs:{id:"疑惑解释"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#疑惑解释"}},[t._v("#")]),t._v(" 疑惑解释")]),t._v(" "),v("p",[t._v("如果步骤1，请求端发送SYN丢失了怎么办？之前说过TCP的重传确认机制，所以请求端会以指数退避的方式超时重传，第一次重传在6s左右，第二次在24s左右， 直到达到系统设置的最长超时时间返回连接超时错误。")]),t._v(" "),v("p",[t._v("当我们试图连接的目的IP和端口并没有对应的TCP服务监听时，会收到响应端的RST重置连接分组，这一点相比于UDP会返回ICMP不可达差错不同。 如果步骤2响应端发送的捎带ACK的SYN分组丢失，在没有收到步骤3的ACK前，也会一直超时重传。当步骤2收到步骤1重复的SYN，即使没有超时也会进行快速重传的操作。")]),t._v(" "),v("p",[t._v("对于请求端，在收到步骤2的ACK时候连接状态处于ESTABLISHED状态，并发回ACK。此时请求端已经可以开始发送数据。但对于响应端来说，如果没有收到ACK， 则没有进入ESTABLISHED状态，因为还没确认请求端的接收能力。这时如果请求开始发送数据，则会把ACK捎带过来，响应端则能够进入ESTABLISHED状态。 如果一直没有收到请求端的最后一个ACK，则响应端会重复步骤2超时重传，请求端收到后会重发ACK。所以我们可以看出，TCP连接的建立为什么是三次握手。")]),t._v(" "),v("p",[t._v("假想一下，TCP两边同时打开的情况是怎样，原理是一样的。主动打开发送SYN，两边同时进入SYN_SENT状态。当收到对方的SYN，进入SYN_RCVD状态，就再发送己方的SYN并带上ACK。当双方都收到对方的ACK则进入ESTABLISHED状态。")]),t._v(" "),v("p",[t._v("当TCP三次握手完成后，会被放入呼入连接队列，等待应用层接收accept从该队列移出。应用层可以指明backlog，该参数与队列长度正相关，姑且认为就是队列长度。 对于新的连接请求，如果该TCP监听端点的队列还有空间，则TCP模块将对SYN进行确认并完成后续连接的建立，但应用层只有等待三次握手第三个分组到达之后才能知道连接的存在， 也就是还没放入队列中。如果请求端已进入ESTABLISHED状态，则发送的数据，将会放在连接的接收缓冲区中。如果队列没有空间，则试图建立新连接的SYN分组到达，TCP将丢弃不理会， 由请求端超时重发。")]),t._v(" "),v("h3",{attrs:{id:"tcp连接如何终止"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接如何终止"}},[t._v("#")]),t._v(" TCP连接如何终止")]),t._v(" "),v("p",[t._v("TCP连接断开需要经历四次握手。")]),t._v(" "),v("p",[t._v("正常终止一个连接需要四次握手，这是由TCP半关闭造成的。TCP连接是全双工的，所以每个方向都需要单独关闭。当数据发送完毕是，通过发送FIN分组终止这个方向的连接。 收到请求端的FIN，响应端知道请求端不会再有数据过来，但响应端还可以继续发送数据给请求端，直到发送完毕再发送FIN。")]),t._v(" "),v("ol",[v("li",[t._v("首先是主动关闭端，发送FIN，FIN占用一个序号，seq2854，主动端进入"),v("code",[t._v("FIN_WAIT1")]),t._v("状态。可以看到，第一个FIN下一个的ACK并不是终止序列的一部分，它是对之前数据的ACK。真正ACK是由接着的一个FIN捎带上了，这是因为被动端已经没有数据发送所以进入"),v("code",[t._v("CLOSE_WAIT")]),t._v("状态后，立刻发送FIN捎带ACK进入"),v("code",[t._v("LAST_ACK")]),t._v("状态。")]),t._v(" "),v("li",[t._v("被动端收到FIN后进入"),v("code",[t._v("CLOSE_WAIT")]),t._v("状态，发送ACK，并等待不再有数据需要发送。主动端收到被动端的ACK2855后，进入FIN_WAIT2状态。等待被动端发送FIN，告知结束数据发送。")]),t._v(" "),v("li",[t._v("被动端发送FIN，seq4314，进入"),v("code",[t._v("LAST_ACK")]),t._v("状态。主动端收到后，进入"),v("code",[t._v("TIME_WAIT")]),t._v("状态，并发送ACK4315。进入TIME_WAIT状态后，等待2MSL（最大报文段生存时间）后进入"),v("code",[t._v("CLOSED")]),t._v("状态终止。")]),t._v(" "),v("li",[t._v("被动端收到ACK后，进入"),v("code",[t._v("CLOSED")]),t._v("状态，连接正常终止。")])]),t._v(" "),v("h4",{attrs:{id:"疑惑解释-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#疑惑解释-2"}},[t._v("#")]),t._v(" 疑惑解释")]),t._v(" "),v("p",[t._v("对于终止连接，主要有shutdown和close系统调用。shutdown关闭读时，接收缓冲区数据将被丢弃，后续数据也会被丢弃，read会返回结束EOF。 但是如果对方有新的数据到达，则会响应ACK然后悄悄丢弃。shutdown关闭写时，这就是半关闭，不管socket的引用计数，都会直接关闭写， 将发送缓冲区已有的数据发送出去，然后发送FIN给对端。如果再对socket进行write则会抛出EPIPE错误。shutdown关闭读写。相当于既关闭读又关闭写。 close关闭，是将socket的引用计数减去1。当socket引用计数为0时，会向对端发送FIN，然后回收连接和资源。当对端发送分组时，则会响应一个RST复位连接分组。")]),t._v(" "),v("p",[t._v("如果步骤2，主动端进入FIN_WAIT2状态后，等待接收被动端的FIN，如果被动端一直没有发送，或者FIN丢失了。那主动端会一直处于FIN_WAIT2，被动端会一直处于CLOSE_WAIT。 如果进行半关闭，这是由应用层来决定的。如果进行全关闭，则会设置一个定时器，超过等待时间则直接进入CLOSED状态。")]),t._v(" "),v("p",[t._v("对于步骤3，主动端收到FIN后进入TIME_WAIT状态，为什么要等待2倍MSL时间才进入CLOSED状态？我们可以想一下如果四次握手，最后一个ACK丢失了， 而主动端不等待2倍MSL就进入CLOSED状态。那么被动端超时重传，主动端则会返回一个RST复位报文段。所以为了TCP的正常终止， TIME_WAIT需要等待一去（ACK）一回（重发的FIN）最多两个报文段的MSL。处于TIME_WAIT状态时，定义这个连接的插口对网络四元组不能再被使用。 处于该状态时，网络中迟到的数据分组到达时都会被丢弃。因为等待2倍MSL，所以在被动端发送FIN之前的所有数据分组都会在网络中消亡。如果不等待， 同样的插口对建立新连接，当老的数据分组到达时就会被错误认为是该连接的数据分组。所以总结就是两点：为了保证TCP连接的正常终止，为了使网络中迷途 的数据分组正常过期。")]),t._v(" "),v("p",[t._v("连接建立后，客户端拔掉网线或断电，会发生什么？这时服务端的状态还是ESTABLISHED，并不知道对方发生了什么。当服务端发送数据报给客户端，如果客户端已经断电或断网了， 则没有客户端给服务端发回响应。服务端将一直重发直到超时。如果客户端已经恢复，服务端发送数据到客户端，这时客户端并不存在该连接，则会返回RST复位报文段。这种情况 称为半打开连接。所以为了避免这种情况，在保持长连接的应用需要从应用层建立心跳机制。TCP提供了保活定时器，通过设置keep-alive，但连接超过一定时间没有数据交互， 则发送探测分组。")]),t._v(" "),v("p",[t._v("如果连接双方同时关闭，同时发出FIN，进入FIN_WAIT1，收到对方FIN时进入CLOSING状态，并发回ACK。收到对方ACK时，则进入TIME_WAIT状态。 通过设置SO_LINGER可以使关闭连接时发送的是RST复位报文段而不是FIN报文段。")]),t._v(" "),v("h3",{attrs:{id:"tpc传输过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tpc传输过程"}},[t._v("#")]),t._v(" TPC传输过程")]),t._v(" "),v("p",[t._v("后期解释，暂时略")]),t._v(" "),v("h2",{attrs:{id:"网络层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络层"}},[t._v("#")]),t._v(" 网络层")]),t._v(" "),v("h3",{attrs:{id:"什么是arp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是arp协议"}},[t._v("#")]),t._v(" 什么是ARP协议？")]),t._v(" "),v("blockquote",[v("p",[t._v("ARP协议：地址解析协议（Address Resolution Protocol）")]),t._v(" "),v("p",[t._v("百科介绍：https://baike.baidu.com/item/ARP/609343?fr=aladdin#2")])]),t._v(" "),v("p",[t._v("它是用于将IP地址转换成对应主机的MAC地址（以太网接口硬件地址）。机器之间在硬件层次上进行数据帧的交换必须有正确的接口地址。 所以内核在发送数据之前必须知道目的端的硬件地址才能发送数据。在局域网LAN如果目的主机在同一网络，则会发ARP广播，目的主机收到广播消息后，会返回对应的硬件地址。 返回的硬件地址会被存在arp高速缓存中。下一次则无需再发广播获取。如果目的IP不是在局域网LAN那又如何？首先比较混淆的一点是ARP获取的目的主机MAC地址，这里的目的主机并不是指 目的IP地址对应的主机。这就涉及到IP路由选择的概念，如果目的IP选择默认的下一站路由，则IP数据报会先发送给下一站路由再由其转发。 那么通过ARP获取的就是这个下一站路由IP对应的MAC地址。我们可以通过arp -a命令查看当前arp高速缓存。通过tcpdump arp我们可以查看arp的请求和应答。")]),t._v(" "),v("h3",{attrs:{id:"什么是rarp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是rarp协议"}},[t._v("#")]),t._v(" 什么是RARP协议？")]),t._v(" "),v("p",[t._v("既然有地址解析协议，就有RARP逆地址解析协议。发送主机发送RARP广播，收到广播的RARP服务器给源主机发送包含IP地址的响应。现在这个协议已过时，取而代之的是DHCP协议。")]),t._v(" "),v("h3",{attrs:{id:"什么是ip协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是ip协议"}},[t._v("#")]),t._v(" 什么是IP协议？")]),t._v(" "),v("p",[t._v("IP协议是TCP/IP协议族的网络层协议，提供不可靠无连接无顺序的数据报传输服务。这个定义其实已经把协议的特点讲得很清楚。 不可靠指的是IP数据报并不保证到达目的主机。无连接指的是，IP层不会维护任何关于数据报的状态信息，每个数据报处理相互独立。无顺序指的是因为每一个数据报都是独立处理， 而且传递过程是逐跳传递，每一个数据报的路由选择都可能不同，甚至有的可能中途丢弃，所以数据报到达目的主机的顺序是无法保证的。")]),t._v(" "),v("h3",{attrs:{id:"ip数据报数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ip数据报数据结构"}},[t._v("#")]),t._v(" IP数据报数据结构？")]),t._v(" "),v("p",[t._v("这个相对复杂，这里暂时不做介绍。")]),t._v(" "),v("h3",{attrs:{id:"ip地址有几类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ip地址有几类"}},[t._v("#")]),t._v(" IP地址有几类？")]),t._v(" "),v("p",[t._v("IP地址格式为前置位+网络号+主机号。可以分为5类地址。")]),t._v(" "),v("p",[t._v("A类地址：0 + 7位网络号 + 24位主机号。B类地址：10 + 14位网络号 + 16位主机号。C类地址：110 + 21位网络号 + 8位主机号。D类地址：1110 + 28位多播组号。 E类地址：11110 + 27位备用。")]),t._v(" "),v("p",[t._v("IP地址分为公网地址和私有地址，私有地址只在局域网中使用。A类私有地址，127.X.X.X，10.X.X.X。B类私有地址，172.16.0.0到172.31.255.255。 C类私有地址，192.0.0.0到192.168.255.255。")]),t._v(" "),v("p",[t._v("在每一类地址，可以进一步向主机位借位划分子网。在局域网中，可以将地址划分成多个网段，由子网掩码标识对应地址的网络号。处于同一个网段的主机可以进行相互通信， 处于同一网段的主机才能接收彼此的ARP广播。通过子网掩码可以判断目的主机是否属于同一个网段，如果不属于同一个网段，则数据需要发给网关，由网关负责转发。 通过划分子网，可以减小路由表，减少广播域，节约ip地址。互联网能够访问的只有公网IP地址，而我们家庭上网时，经常看到使用的是私有地址。这是通过NAT技术实现， 将局域网的私有地址映射到一个公有地址，并负责数据的转发和接收。")]),t._v(" "),v("h3",{attrs:{id:"什么是icmp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是icmp协议"}},[t._v("#")]),t._v(" 什么是ICMP协议？")]),t._v(" "),v("p",[t._v("前面我们提到了ICMP协议，Internet控制报文协议。它被认为是IP层的一个附属协议。主要是用来传递差错信息和查询信息。ICMP报文是在IP数据报内容部分。 ICMP报文的结构也比较简单：8位类型+8位代码+16位检验和+内容部分。这里的16位检验和，检验的是整个ICMP报文，其检验方法同IP首部检验和一样。常见的ICMP查询报文 主要有：回显请求和应答，路由器请求和通告报文，时间戳请求和应答，地址掩码请求和应答。常见的ICMP差错报文主要有：网络不可达，主机不可达，端口不可达， 重定向差错报文，超时报文")]),t._v(" "),v("h3",{attrs:{id:"ping程序原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ping程序原理"}},[t._v("#")]),t._v(" ping程序原理")]),t._v(" "),v("p",[t._v("前面我们提到了ICMP常见的查询报文有回显请求和应答。ping程序正是通过ICMP报文实现的。通过在报文中携带标识序号和时间戳。ping程序收到应答的时候， 根据当前时间减去报文中的时间戳，就能得出往返时间RTT，也能查看网络数据报收发情况。")]),t._v(" "),v("h2",{attrs:{id:"数据链路层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[t._v("#")]),t._v(" 数据链路层")]),t._v(" "),v("h3",{attrs:{id:"数据链路层的职责是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层的职责是什么"}},[t._v("#")]),t._v(" 数据链路层的职责是什么？")]),t._v(" "),v("p",[t._v("数据链路层通常包括操作系统中的设备驱动程序和计算机中对应的网路接口，负责处理与电缆的物理接口细节。在TCP/IP协议族中主要是为了上层IP模块发送数据和接受数据的。为ARP模块和RARP模块发送请求和应答。在TCP/IP协议中，ARP，RARP，IP都属于网络层。")]),t._v(" "),v("h2",{attrs:{id:"网络安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络安全"}},[t._v("#")]),t._v(" 网络安全")]),t._v(" "),v("p",[t._v("常见的网络安全有XSS和CSRF，下面就简单介绍一下；")]),t._v(" "),v("h3",{attrs:{id:"xss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xss"}},[t._v("#")]),t._v(" XSS")]),t._v(" "),v("p",[t._v("xss: 跨站脚本攻击（Cross Site Scripting）是最常见和基本的攻击 WEB 网站方法，攻击者通过注入非法的 html 标签或者 javascript 代码，从而当用户浏览该网页时，控制用户浏览器。")]),t._v(" "),v("h4",{attrs:{id:"xss-主要分为三类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xss-主要分为三类"}},[t._v("#")]),t._v(" xss 主要分为三类：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("DOM xss：")]),t._v(" "),v("p",[t._v("DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。")])]),t._v(" "),v("li",[v("p",[t._v("反射性 xss：")]),t._v(" "),v("p",[t._v("反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。")])]),t._v(" "),v("li",[v("p",[t._v("存储性 xss：")]),t._v(" "),v("p",[t._v("存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);