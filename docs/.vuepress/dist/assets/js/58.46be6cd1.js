(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{419:function(t,a,s){"use strict";s.r(a);var r=s(45),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"计算机基础笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机基础笔记"}},[t._v("#")]),t._v(" 计算机基础笔记")]),t._v(" "),s("p",[t._v("计算机基础原理、学习内容做一下笔记")]),t._v(" "),s("h3",{attrs:{id:"进程和线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[t._v("#")]),t._v(" 进程和线程")]),t._v(" "),s("ul",[s("li",[t._v("进程是系统资源分配、调度和管理的最小单位")]),t._v(" "),s("li",[t._v("线程是cpu运算的最小执行单位")])]),t._v(" "),s("h4",{attrs:{id:"进程概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程概述"}},[t._v("#")]),t._v(" 进程概述")]),t._v(" "),s("p",[t._v("我们知道文件是对I/O设备的抽象，虚拟存储器是对文件和主存的抽象，指令集是对CPU的抽象，进程是对指令集和虚拟存储器的抽象。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/4/20/162e0940cbe7782f?imageslim",alt:"img"}})]),t._v(" "),s("h4",{attrs:{id:"虚拟内存的逻辑布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存的逻辑布局"}},[t._v("#")]),t._v(" 虚拟内存的逻辑布局")]),t._v(" "),s("p",[t._v("虚拟内存包括用户栈、堆、程序数据和程序代码，程序数据和程序代码从可执行文件加载而来的。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/4/20/162e0940cec14767?imageslim",alt:"img"}})]),t._v(" "),s("p",[t._v("此时，CPU运行到地址为304的指令， 假设CPU时间片刚好用完，就需要进行进程切换，在进行进程切换之前，需要保护现场，即保存寄存器信息、PC、打开的文件， 代码段地址、数据地址、堆栈信息等，这些信息称为"),s("strong",[t._v("进程的上下文")]),t._v("。当操作系统切换到进程时，首先将进程2的上下文信息加载到操作系统中，找到PC，然后接着执行就可以了。")]),t._v(" "),s("h4",{attrs:{id:"进程控制块pcb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程控制块pcb"}},[t._v("#")]),t._v(" 进程控制块PCB")]),t._v(" "),s("p",[t._v("进程的上下文信息是以某个数据结构保存在内存中的，而这种数据结构就是PCB。在Linux操作系统中PCB对应的数据结构就是task_struct，它保存着进程的重要信息。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("struct task_struct"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  pid_t pid"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("进程号\n  long state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//状态")]),t._v("\n  cputime_t utime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("stime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//cpu在用户态和 核心态下执行的时间")]),t._v("\n  struct files_struct "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("files"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//打开的文件")]),t._v("\n  struct   mm_struct  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mm"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//进程使用的内存")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h4",{attrs:{id:"node线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node线程"}},[t._v("#")]),t._v(" node线程")]),t._v(" "),s("p",[t._v("node并不是单线程的，因为node是使用的c++写的，所以底层c++在实现的时候使用了多线程来处理，我们用户能够操作的是单线程的。")]),t._v(" "),s("h4",{attrs:{id:"线程的五中状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程的五中状态"}},[t._v("#")]),t._v(" 线程的五中状态")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pic4.zhimg.com/80/v2-03c79fba62101ca3d49fefdf45c08f36_720w.png",alt:"image-20210130150503751"}})]),t._v(" "),s("ul",[s("li",[t._v("初始化(New)：初始化状态，可以理解为实例")]),t._v(" "),s("li",[t._v("可运行(Runnable)：可运行是说明实例化正常了，可以看做thread.start")]),t._v(" "),s("li",[t._v("阻塞(Blocked)：线程阻塞，不占用cpu资源")]),t._v(" "),s("li",[t._v("运行中(Running)：可运行之后抢占到了cpu执行")]),t._v(" "),s("li",[t._v("销毁(Dead)：线程销毁")])]),t._v(" "),s("p",[t._v("以上五中状态只有运行中会占用到cpu资源的。")]),t._v(" "),s("h5",{attrs:{id:"流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),s("p",[t._v("我们来介绍了一下五个状态的流程是怎么样的。")]),t._v(" "),s("p",[t._v("首先进程会被创建，然后进入到可运行状态，此时，进程并没有进入到运行状态，而是等待CPU调度，如果被CPU调度则进入到运行状态，而当时间片用完时，进程从运行状态返回到可运行状态，而当等待I/O操作时，则由运行态进入阻塞态。")]),t._v(" "),s("h4",{attrs:{id:"cpu调度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu调度"}},[t._v("#")]),t._v(" CPU调度")]),t._v(" "),s("p",[t._v("如上所述，"),s("strong",[t._v("CPU调度就是到底哪个线程占有CPU")]),t._v("，它可以分为"),s("strong",[t._v("非抢占式")]),t._v("和"),s("strong",[t._v("抢占式")]),t._v("。非抢占式是指调度程序一旦把CPU分配给某一进程后便让它一直运行下去，直到进程完成或发生某件事件而不能运行时，才将CPU分配给其他线程。它适合批处理系统，简单、系统开销小。抢占式是指当一个线程正在执行时，系统可以基于某种策略剥夺CPU给其他进程。剥夺的原则有优先权原则、端进程优先原则、时间片原则，它适用于交互式系统。")]),t._v(" "),s("h4",{attrs:{id:"线程创建、销毁和切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程创建、销毁和切换"}},[t._v("#")]),t._v(" 线程创建、销毁和切换")])])}),[],!1,null,null,null);a.default=e.exports}}]);