(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{408:function(e,t,o){"use strict";o.r(t);var r=o(45),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"react组件生命周期"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react组件生命周期"}},[e._v("#")]),e._v(" react组件生命周期")]),e._v(" "),o("p",[e._v("react组件进入到离开需要经历一些列的生命周期方法，下面就是"),o("code",[e._v("class")]),e._v("模式下的生命周期函数，在17版本之后有些会被弃用：")]),e._v(" "),o("h3",{attrs:{id:"_1-constructor"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-constructor"}},[e._v("#")]),e._v(" 1. constructor()")]),e._v(" "),o("p",[e._v("构造函数执行，初始化数据，"),o("code",[e._v("super")]),e._v("继承数据。")]),e._v(" "),o("h3",{attrs:{id:"_2-componentwillmount"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-componentwillmount"}},[e._v("#")]),e._v(" 2. componentWillMount()")]),e._v(" "),o("p",[e._v("在渲染前调用,在客户端也在服务端，它只发生一次。")]),e._v(" "),o("h3",{attrs:{id:"_3-render"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-render"}},[e._v("#")]),e._v(" 3.render")]),e._v(" "),o("p",[e._v("页面初始化渲染一次，后面挂载的时候也会被执行。")]),e._v(" "),o("h3",{attrs:{id:"_4-componentdidmount"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-componentdidmount"}},[e._v("#")]),e._v(" 4. componentDidMount()")]),e._v(" "),o("p",[e._v("在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过"),o("code",[e._v("this.getDOMNode()")]),e._v("来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用"),o("code",[e._v("setTimeout")]),e._v(", "),o("code",[e._v("setInterval")]),e._v("或者发送AJAX请求等操作(防止异部操作阻塞UI)。")]),e._v(" "),o("p",[e._v("在这前"),o("code",[e._v("render")]),e._v("函数已经执行一遍了。")]),e._v(" "),o("h3",{attrs:{id:"_5-componentwillreceiveprops"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-componentwillreceiveprops"}},[e._v("#")]),e._v(" 5. componentWillReceiveProps()")]),e._v(" "),o("p",[e._v("在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。")]),e._v(" "),o("h3",{attrs:{id:"_6-shouldcomponentupdate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_6-shouldcomponentupdate"}},[e._v("#")]),e._v(" 6. shouldComponentUpdate()")]),e._v(" "),o("p",[e._v("返回一个布尔值。在组件接收到新的"),o("code",[e._v("props")]),e._v("或者"),o("code",[e._v("state")]),e._v("时被调用。在初始化时或者使用"),o("code",[e._v("forceUpdate")]),e._v("时不被调用。 可以在你确认不需要更新组件时使用。")]),e._v(" "),o("h3",{attrs:{id:"_7-componentwillupdate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_7-componentwillupdate"}},[e._v("#")]),e._v(" 7. componentWillUpdate()")]),e._v(" "),o("p",[e._v("在组件接收到新的"),o("code",[e._v("props")]),e._v("或者"),o("code",[e._v("state")]),e._v("但还没有"),o("code",[e._v("render")]),e._v("时被调用。在初始化时不会被调用。")]),e._v(" "),o("h3",{attrs:{id:"_8-componentdidupdate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_8-componentdidupdate"}},[e._v("#")]),e._v(" 8. componentDidUpdate()")]),e._v(" "),o("p",[e._v("在组件完成更新后立即调用。在初始化时不会被调用。")]),e._v(" "),o("h3",{attrs:{id:"_9-componentwillunmount"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_9-componentwillunmount"}},[e._v("#")]),e._v(" 9. componentWillUnMount()")]),e._v(" "),o("p",[e._v("组件从 DOM 中移除的时候立刻被调用。")]),e._v(" "),o("h2",{attrs:{id:"未来版本中有三个生命周期会弃用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#未来版本中有三个生命周期会弃用"}},[e._v("#")]),e._v(" 未来版本中有三个生命周期会弃用")]),e._v(" "),o("h3",{attrs:{id:"_1-componentwillmound"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-componentwillmound"}},[e._v("#")]),e._v(" 1. componentWillMound")]),e._v(" "),o("blockquote",[o("p",[e._v("注意")]),e._v(" "),o("p",[e._v("此生命周期之前名为 "),o("code",[e._v("componentWillMount")]),e._v("。该名称将继续使用至 React 17。可以使用 "),o("a",{attrs:{href:"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("rename-unsafe-lifecycles")]),e._v(" codemod"),o("OutboundLink")],1),e._v(" 自动更新你的组件。")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("UNSAFE_componentWillMount()")]),e._v(" 在挂载之前被调用。它在 "),o("code",[e._v("render()")]),e._v(" 之前调用，因此在此方法中同步调用 "),o("code",[e._v("setState()")]),e._v(" 不会触发额外渲染。通常，我们建议使用 "),o("code",[e._v("constructor()")]),e._v(" 来初始化 state。")]),e._v(" "),o("p",[e._v("避免在此方法中引入任何副作用或订阅。如遇此种情况，请改用 "),o("code",[e._v("componentDidMount()")]),e._v("。")]),e._v(" "),o("p",[e._v("此方法是服务端渲染唯一会调用的生命周期函数。")])]),e._v(" "),o("h3",{attrs:{id:"_2-componentwillreceiveprops"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-componentwillreceiveprops"}},[e._v("#")]),e._v(" 2. componentWillReceiveProps()")]),e._v(" "),o("blockquote",[o("p",[e._v("此生命周期之前名为 "),o("code",[e._v("componentWillReceiveProps")]),e._v("。该名称将继续使用至 React 17。可以使用 "),o("a",{attrs:{href:"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("rename-unsafe-lifecycles")]),e._v(" codemod"),o("OutboundLink")],1),e._v(" 自动更新你的组件。")])]),e._v(" "),o("blockquote",[o("p",[e._v("注意:")]),e._v(" "),o("p",[e._v("使用此生命周期方法通常会出现 bug 和不一致性：")]),e._v(" "),o("ul",[o("li",[e._v("如果你需要"),o("strong",[e._v("执行副作用")]),e._v("（例如，数据提取或动画）以响应 props 中的更改，请改用 "),o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidupdate",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("componentDidUpdate")]),o("OutboundLink")],1),e._v(" 生命周期。")]),e._v(" "),o("li",[e._v("如果你使用 "),o("code",[e._v("componentWillReceiveProps")]),e._v(" "),o("strong",[e._v("仅在 prop 更改时重新计算某些数据")]),e._v("，请"),o("a",{attrs:{href:"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用 memoization helper 代替"),o("OutboundLink")],1),e._v("。")]),e._v(" "),o("li",[e._v("如果你使用 "),o("code",[e._v("componentWillReceiveProps")]),e._v(" 是为了"),o("strong",[e._v("在 prop 更改时“重置”某些 state")]),e._v("，请考虑使组件"),o("a",{attrs:{href:"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component",target:"_blank",rel:"noopener noreferrer"}},[e._v("完全受控"),o("OutboundLink")],1),e._v("或"),o("a",{attrs:{href:"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用 "),o("code",[e._v("key")]),e._v(" 使组件完全不受控"),o("OutboundLink")],1),e._v(" 代替。")])]),e._v(" "),o("p",[e._v("对于其他使用场景，"),o("a",{attrs:{href:"https://react.docschina.org/blog/2018/06/07/you-probably-dont-need-derived-state.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("请遵循此博客文章中有关派生状态的建议"),o("OutboundLink")],1),e._v("。")])]),e._v(" "),o("h3",{attrs:{id:"_3-componentwillupdate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-componentwillupdate"}},[e._v("#")]),e._v(" 3.componentWillUpdate()")]),e._v(" "),o("blockquote",[o("p",[o("strong",[e._v("注意")])]),e._v(" "),o("p",[e._v("此生命周期之前名为 "),o("code",[e._v("componentWillUpdate")]),e._v("。该名称将继续使用至 React 17。可以使用 "),o("a",{attrs:{href:"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("rename-unsafe-lifecycles")]),e._v(" codemod"),o("OutboundLink")],1),e._v(" 自动更新你的组件。")])]),e._v(" "),o("blockquote",[o("p",[e._v("当组件收到新的 props 或 state 时，会在渲染之前调用 "),o("code",[e._v("UNSAFE_componentWillUpdate()")]),e._v("。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。")]),e._v(" "),o("p",[e._v("注意，你不能此方法中调用 "),o("code",[e._v("this.setState()")]),e._v("；在 "),o("code",[e._v("UNSAFE_componentWillUpdate()")]),e._v(" 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新")]),e._v(" "),o("p",[e._v("通常，此方法可以替换为 "),o("code",[e._v("componentDidUpdate()")]),e._v("。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 "),o("code",[e._v("getSnapshotBeforeUpdate()")]),e._v(" 中。")])]),e._v(" "),o("p",[o("a",{attrs:{href:"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[e._v("查看react的生命周期"),o("OutboundLink")],1)]),e._v(" "),o("p",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("react官网生命周期介绍"),o("OutboundLink")],1)]),e._v(" "),o("h2",{attrs:{id:"react17-0组件的生命周期"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react17-0组件的生命周期"}},[e._v("#")]),e._v(" react17.0组件的生命周期")]),e._v(" "),o("p",[e._v("每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。"),o("strong",[e._v("你可以使用此"),o("a",{attrs:{href:"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[e._v("生命周期图谱"),o("OutboundLink")],1),e._v("作为速查表")]),e._v("。在下述列表中，常用的生命周期方法会被加粗。其余生命周期函数的使用则相对罕见。")]),e._v(" "),o("p",[e._v("当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：")]),e._v(" "),o("h3",{attrs:{id:"挂载"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#挂载"}},[e._v("#")]),e._v(" 挂载")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#constructor",target:"_blank",rel:"noopener noreferrer"}},[o("strong",[o("code",[e._v("constructor()")])]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("static getDerivedStateFromProps()")]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#render",target:"_blank",rel:"noopener noreferrer"}},[o("strong",[o("code",[e._v("render()")])]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidmount",target:"_blank",rel:"noopener noreferrer"}},[o("strong",[o("code",[e._v("componentDidMount()")])]),o("OutboundLink")],1)])]),e._v(" "),o("h3",{attrs:{id:"更新"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[e._v("#")]),e._v(" 更新")]),e._v(" "),o("p",[e._v("当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("static getDerivedStateFromProps()")]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#shouldcomponentupdate",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("shouldComponentUpdate()")]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#render",target:"_blank",rel:"noopener noreferrer"}},[o("strong",[o("code",[e._v("render()")])]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#getsnapshotbeforeupdate",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("getSnapshotBeforeUpdate()")]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidupdate",target:"_blank",rel:"noopener noreferrer"}},[o("strong",[o("code",[e._v("componentDidUpdate()")])]),o("OutboundLink")],1)])]),e._v(" "),o("h3",{attrs:{id:"卸载"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[e._v("#")]),e._v(" 卸载")]),e._v(" "),o("p",[e._v("当组件从 DOM 中移除时会调用如下方法：")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentwillunmount",target:"_blank",rel:"noopener noreferrer"}},[o("strong",[o("code",[e._v("componentWillUnmount()")])]),o("OutboundLink")],1)])]),e._v(" "),o("h3",{attrs:{id:"错误处理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[e._v("#")]),e._v(" 错误处理")]),e._v(" "),o("p",[e._v("当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#static-getderivedstatefromerror",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("static getDerivedStateFromError()")]),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/react-component.html#componentdidcatch",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("componentDidCatch()")]),o("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);