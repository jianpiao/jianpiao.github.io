# 红包雨

## 前言

双十一各大购物平台开启了红包雨活动，点击红包即可获得相对应金额奖励。

那我们能不能自己实现一个红包雨游戏，以后适当时期加入到光环社区活动中呢？

## 目标

红包雨能够支持PC端、移动端落地页投放，游戏尺寸能够适配各种设备。

**游戏规则**

* 红包会从页面顶部随机数量、位置落下
* 点击下落的红包弹出点击反馈动画
* 游戏时长为20秒钟
* 游戏结束可以领取奖励

## 红包雨游戏

这里以phaser2版本作为游戏开发基础。

## 游戏核心概括

游戏最核心的部分如下：

### 1. 引擎系统

这次红包雨用到的是**arcade**物理引擎，它包含碰撞、重叠、运动相关的方法。

红包雨下落需要用到物理属性如下：

**速度velocity属性**

```javascript
redPacket.body.velocity.x = game.rnd.integerInRange(-200, 100);   //红包移动的速度
redPacket.body.velocity.y = game.rnd.integerInRange(gameOptions.minSpeed, gameOptions.maxSpeed);
```

**重力gravity**

```javascript
game.physics.arcade.gravity.y = 2000;
```

### 2. 红包精灵(sprite)

红包是属于`sprite`精灵元素，它可以有物理属性。

红包由`spritesheet`加载生成，它被切分成为两帧动画。

```javascript
game.load.spritesheet('redpacket', 'assets/img/redpacket.png', 144, 173, 2) // 红包，两帧
```

红包默认显示第一帧动画，当点击之后，切换显示第二帧

```javascript
// 给红包添加帧动画
let anim = sprite.animations.add(gameOptions.selfPic);
// 执行帧动画
sprite.play(gameOptions.selfPic, 20, false);
// 帧动画切换完毕后，执行补间动画，让红包渐变消失
anim.onComplete.add(this.killed, this, sprite)
```

## 游戏环境搭建

使用的phaser2版本，红包雨用到了`arcade`物理引擎，需要额外引入pixi.js和p2.js。

本次新增了两个音效，一个是游戏进行中的背景音，一个是开奖音效。在项目中直接使用`audio`的原生API进行播放、暂停、重新播放。

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=750,minimum-scale=0.5,maximum-scale=0.5,initial-scale=0.5" />
  <title>红包雨</title>
</head>

<body>
  <div id="app"></div>
  <audio id="audioOpen" src='assets/audio/open-redpacket.mp3'></audio>
  <audio id="playing" src='assets/audio/playing.mp3'></audio>
  <script src='./js/pixi.js'></script>
  <script src='./js/p2.js'></script>
  <script src='./js/phaser-split.js'></script>
  <script src="app.js" charset="utf-8"></script>
  <script type="module" src="/main.js"></script>
</body>

</html>
```

基础内容加载完毕后，开始实例化并启动游戏。

```javascript
import './style.css'

// 游戏主体
let game;

// 游戏基本配置,用于创建游戏画布
const gameOptions = {
  gameWidth: document.documentElement.clientWidth,
  gameHeight: document.documentElement.clientHeight,
  renderer: Phaser.AUTO,
  parent: document.getElementById('gameScreen'),
  selfPool: 10,
  selfPic: 'redpacket',
  rate: 0.15,
  maxSpeed: 200,
  minSpeed: 50,
  max: 95,
  time: 20, // 游戏时长
  awardText: "恭喜获得女票一位"
}

// 让它在页面加载后执行
window.onload = function () {
  const { gameWidth, gameHeight, renderer, parent } = gameOptions

  // 使用Phaser引擎创建一个游戏
  game = new Phaser.Game(gameWidth, gameHeight, renderer, parent);

  // 添加游戏
  game.state.add("TheGame", TheGame);

  // 启动游戏
  game.state.start("TheGame");
}
```

把游戏添加到`state`场景中，然后将场景中的游戏启动。

### 预加载资源

搭建舞台场景，设置舞台的背景色（后面添加背景图会覆盖掉）。

加载瓦片的资源，游戏中用到所有资源在此逐一加载。

```javascript
  // 资源预加载，会在phaser预加载期间执行，可以实时监控资源加载的进度
  preload() {
    if (typeof (GAME) !== "undefined") {
      this.load.baseURL = GAME + "/";
    }

    // 将游戏覆盖整个屏幕，同时保持其比例
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;

    // 游戏水平居中
    game.scale.pageAlignHorizontally = true;

    // 游戏垂直居中
    game.scale.pageAlignVertically = true;

    // 设置舞台背景色
    game.stage.backgroundColor = '#000';

    //加载图片
    game.load.image('launchBg', 'assets/img/bg-plan.jpg')
    game.load.image('bgRainer', 'assets/img/bg-rainer.jpg')
    game.load.spritesheet('redpacket', 'assets/img/redpacket.png', 144, 173, 2) // 红包，两帧
    game.load.image('close', 'assets/img/close.png')
    game.load.image('dialogExit', 'assets/img/dialog-exit.png')
    game.load.image('buttonExit', 'assets/img/button-exit.png')
    game.load.image('buttonCancel', 'assets/img/button-cancel.png')
    game.load.image('openRedpacket', 'assets/img/open-redpacket.png')
    game.load.image('open', 'assets/img/open.png')
    game.load.image('redpacketResult', 'assets/img/redpacket-result.png')
    game.load.image('buttonContinue', 'assets/img/button-continue.png')
    game.load.image('buttonUseTicket', 'assets/img/button-use-ticket.png')
    game.load.spritesheet('cursorAnimation', 'assets/img/cursor-animation.png', 74, 108, 2) // 手势动画，两帧
    game.load.image('gameStartBtn', 'assets/img/anniu.png')
  }
```

### 创建游戏画布

游戏加载完毕呈现的是启动页，等待用户做好准备，随时开始游戏，在页面底部绘制一个开始游戏按钮，当用户准备好后，点击开始游戏按钮，切换到红包雨执行页。

画布创建初始期间需要提前预设好物理引擎类型，同时设置全部物理元素的重力为2000。

```javascript

// 创建游戏画布，在游戏完全加载后立即执行
create() {
  // 物理系统
  game.physics.startSystem(Phaser.Physics.ARCADE);
  game.physics.arcade.gravity.y = 2000;

  // 背景图
  let launchBg = game.add.sprite(0, 0, 'launchBg');
  launchBg.width = game.width;
  launchBg.height = game.height;

  // 开始按钮背景
  this.gameStartButton = game.add.button(game.world.centerX, gameOptions.gameHeight - 300, "gameStartBtn", function () {
    this.gameStartButton.visible = false
    this.gameStartText.visible = false
    this.cursorHandle.visible = false
    this.startGame()
  }, this);
  this.gameStartButton.anchor.set(0.5, 0)

  // 游戏开始文案
  const gameStartTextStyle = { fill: '#FFF', fontSize: '30px', fontWeight: 'bolder' }
  this.gameStartText = game.add.text(game.world.centerX, gameOptions.gameHeight - 250, '开始游戏', gameStartTextStyle)
  this.gameStartText.anchor.set(0.5, 0.5)

  // 手指
  this.cursorHandle = game.add.sprite(game.world.centerX - 36, gameOptions.gameHeight - 250, 'cursorAnimation')
  this.cursorHandle.animations.add('cursorAnimation')
  this.cursorHandle.play('cursorAnimation', 2, true);
}
```

### 创建游戏元素

当用户点击开始游戏按钮后，会隐藏启动页，展示游戏页，游戏页包含背景图、计时器、退出游戏按钮、红包雨。

其中红包雨用到了`createMultiple`方法，会重复绘制出新的红包精灵，设置了一次性最多绘制数量为10。每次绘制出来新的红包精灵都需要更新新的帧，从而展示到舞台中，这时用到了`game.time.events.loop`方法，我设置了让舞台0.15秒更新一帧，更新的频率比较快，绘制呈现的红包就比较多，如果每1秒钟绘制一帧的话，红包数量显得太少。

以上元素均需要在此时绘制生成并立即展示。

```javascript
  // 开始游戏
  startGame() {
    // 启动游戏进行中音效
    this.gameAudio = document.getElementById('playing')
    this.gameAudio.play()
    this.gameAudio.onended = () => {
      this.gameAudio.currentTime = 0; // 重新播放
      this.gameAudio.play();
    }

    // 红包雨背景图
    let bgRainer = game.add.sprite(0, 0, 'bgRainer');
    bgRainer.width = game.width;
    bgRainer.height = game.height;

    this.config = gameOptions;
    this.redPacketGroup = game.add.group();
    this.redPacketGroup.enableBody = true;
    this.redPacketGroup.createMultiple(gameOptions.selfPool, gameOptions.selfPic); //创建许多红包
    this.redPacketGroup.setAll('anchor.y', 1)
    this.redPacketGroup.setAll('outOfBoundsKill', true);
    this.redPacketGroup.setAll('checkWorldBounds', true);
    game.time.events.loop(Phaser.Timer.SECOND * gameOptions.rate, this.createRedPacket, this);

    // 初始化游戏时间
    this.leftTime = gameOptions.time
    // 剩余时间文案
    this.leftTimeText = game.add.text(0, 0, this.leftTime, { fill: '#FFF', fontSize: '40px', fontWeight: 'bolder' })
    this.leftTimeText.scale.setTo(rfuc(1))
    this.leftTimeText.fixedToCamera = true;
    this.leftTimeText.cameraOffset.setTo(game.camera.width - rfuc(80), rfuc(20));

    // 重复切换帧，第一个参数是一帧间隔时长
    game.time.events.repeat(Phaser.Timer.SECOND, this.leftTime, this.refreshTime, this)

    // 添加右上角退出游戏按钮
    game.add.button(rfuc(20), rfuc(20), 'close', this.showExitDialog, this)

    // 创建退出游戏对话框
    this.createExitDialog()
  }
```

### 红包雨构建

每个红包来源于`this.redPacketGroup`组，从中选取第一个精灵，设置其物理属性。

```javascript
  // 创建红包
  createRedPacket() {
    const redPacket = this.redPacketGroup.getFirstExists(false); // 从组里抽取一个精灵元素
    if (redPacket) {
      redPacket.events.onInputDown.removeAll();
      redPacket.loadTexture(this.config.selfPic)
      redPacket.alpha = 1; // 设置透明度为1
      redPacket.angle = 0 // 红包旋转角度
      redPacket.reset(game.rnd.integerInRange(0, gameOptions.gameWidth - 144), 0)  //红包生成的位置
      redPacket.body.velocity.x = game.rnd.integerInRange(-200, 100);   //红包移动的速度
      redPacket.body.velocity.y = game.rnd.integerInRange(gameOptions.minSpeed, gameOptions.maxSpeed);
      redPacket.inputEnabled = true;
      redPacket.events.onInputDown.add(this.hitRedPacket, this) // 添加点击事件
    }
  }
```

### 点击红包

红包雨下落过程中可以点击红包，红包被点击中后，会展示瓦片精灵第二帧的图（被选中的图）。图展示完毕，开始执行精灵销毁操作，销毁操作可以增加补间动画，让销毁的过程更加美观，这里为了性能考虑没有使用销毁补间动画，每一次红包销毁使用补间动画都会增加极大的性能消耗。

```javascript
  // 点击红包
  hitRedPacket(sprite) {
    // 选中的红包设置为不可点击
    sprite.inputEnabled = false;
    // 给红包添加帧动画
    let anim = sprite.animations.add(gameOptions.selfPic);
    // 执行帧动画
    sprite.play(gameOptions.selfPic, 20, false);
    // 帧动画切换完毕后，执行补间动画，让红包渐变消失
    anim.onComplete.add(this.killed, this, sprite)
  }
```

### 游戏结束

当计时器结束时，代表游戏结束，展示开奖对话框，用户点击弹框金币，执行开奖。

```javascript
  // 展示奖励
  showAwardDialog() {
    this.showAwardGourp = game.add.group()
    this.showAwardResultGroup = game.add.group()
    //背景
    const hexGraphics = new Phaser.Graphics().beginFill(0x000000, 1).drawRect(0, 0, gameOptions.width, gameOptions.height);
    // 遮罩
    const pausedMask = game.add.sprite(0, 0, hexGraphics.generateTexture())
    // 对话框背景图
    const openDialog = game.add.sprite(game.world.centerX, game.world.centerY, 'openRedpacket')
    openDialog.anchor.set(0.5, 0.5)
    // 开奖硬币图
    this.showAwardCoin = game.add.button(game.world.centerX, game.world.centerY + 120, 'open', this.handleOpenCoin.bind(this))
    this.showAwardCoin.anchor.set(0.5, 0.5)
    // 支持点击
    this.showAwardCoin.inputEnabled = true;
    // 将上面添加进组里，方便统一管理
    this.showAwardGourp.add(pausedMask)
    this.showAwardGourp.add(openDialog)
    this.showAwardGourp.add(this.showAwardCoin)

    // 结果背景图
    const result = game.add.sprite(game.world.centerX, game.world.centerY, 'redpacketResult')
    result.anchor.set(0.5, 0.5)
    // 去用券按钮
    this.showAwardUserTicket = game.add.button(game.world.centerX - 130, game.world.centerY + 310, 'buttonUseTicket', this.handleAwardDialogBtn.bind(this))
    this.showAwardUserTicket.anchor.set(0.5, 0.5)
    // 继续抢按钮
    this.showAwardGoOn = game.add.button(game.world.centerX + 130, game.world.centerY + 310, 'buttonContinue', this.handleAwardDialogBtn.bind(this))
    this.showAwardGoOn.anchor.set(0.5, 0.5)
    // 将上面添加进组里，方便统一管理
    this.showAwardResultGroup.add(result)
    this.showAwardResultGroup.add(this.showAwardUserTicket)
    this.showAwardResultGroup.add(this.showAwardGoOn)
    // 先设置抽奖结果为隐藏
    this.showAwardResultGroup.visible = false
  }
```

### 开奖结果

奖品提示文案可以根据实际业务情况进行修改。

```javascript
  // 显示开奖结果
  getAwardResult() {
    document.getElementById('audioOpen').play()
    let ticketStyle = { fill: '#ffe67d', fontSize: '46px', fontWeight: 'bolder' }
    let ticketText = game.add.text(game.world.centerX, game.world.centerY + 75, gameOptions.awardText, ticketStyle) // 奖励结果文案
    ticketText.anchor.set(0.5, 0.5)
    ticketText.left = game.world.centerX - ticketText.width / 2 // 文字居中
    this.showAwardResultGroup.add(ticketText) // 添加进结果组里
    this.showAwardGourp.visible = false // 隐藏开奖前对话框
    this.showAwardResultGroup.visible = true // 显示开奖结果对话框
  }
```

## 总结

以上即为整个游戏的流程。

* 红包使用`spritesheet`精灵图，通过切换画布帧的方式展示未被选中和已被选择两种红包图。
* 红包下落的速度由`Phaser.Physics.ARCADE`物理引擎的`gravity`重力和`velocity`速度决定。
* 启动页和游戏页绘制成的画布由`visible`属性控制显示和隐藏，启动页点击开始游戏后使启动页所有画布隐藏，等游戏结束后，设置其为显示（设置`visible`为`true`）
* 游戏页面左上角有一个关闭按钮，在游戏运行过程中，支持退出游戏和继续游戏操作
* 游戏结束后展示开奖对话框，用户点击游戏币会执行补间动画，摇动游戏币，1秒钟后展示开奖结果
* 游戏重新开始，要重置计时器时间、计时器文案和一些必要的业务逻辑（构造函数的变量都存储在`game`对象作用域链），执行`game.state.restart()`方法重新开始游戏不会重置作用域链中自己定义的变量。
* 为适配不同尺寸设备，以374px为设计基准，以屏幕视口宽度为实际尺寸，利用公式：设计稿比例 * 视口宽度 / 375 得到实际绘制的元素尺寸。
* 游戏中的音效全部使用`audio`标签，音效播放、暂停、重播等操作均使用`audio`原生API

[游戏试玩](https://codesandbox.io/s/nervous-frog-l2tmm?file=/main.js)

[项目地址](https://gitee.com/smallzip/red-packet-rain)

[在线代码阅读](https://github.dev/jianpiao/red-packet-rain)

## 参考文献

[红包雨素材](https://github.com/AmosXu/red-packet-rain)

[phaser官网](https://phaser.io/docs/2.6.2/Phaser.Group.html)

[爱给网音效](https://www.aigei.com/s?q=%E9%A2%86%E7%BA%A2%E5%8C%85&type=sound_category)