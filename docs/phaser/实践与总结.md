# 实践的思考与总结

Phaser游戏开发过程中，会遇到很多稀奇古怪的小问题，最后能够迎刃而解，少不了日常踩坑的思考以及最后给出解决方案。在这里总结一下。

## 物理引擎

往期的游戏中，我们用到了`arcade`物理系统，实现摘星星中任务的跳跃、星星的摘取、炸弹的碰撞。也用到了`p2`物理系统，实现红包雨下落的重叠、不规则下落。此外还有另外一种物理系统 —— `Ninja`。它们三者有什么区别，在什么场景下使用最优，下面就来讲解一下。

### 物理系统

Phaser提供三种物理系统，它们分别是：

1. Arcade：街机物理处理系统。包含碰撞、重叠和运动相关的方法。
2. P2：P2的物理系统。包含碰撞、重叠和运动相关的方法。
3. Ninja：忍者物理系统。包含碰撞、重叠和运动相关的方法

### 差异

Phaser包含了我们常用的`Arcade Physics`系统，以及`Ninja Physics`和`P2.JS`全身物理系统。

`Arcade Physics`（街机物理系统）仅适用于高速AABB碰撞。AABB表示轴对齐的有界矩形，这就意味着所有的碰撞都是基于一个矩阵边界来计算的，所以如果想碰撞一个圆形的精灵（sprite）碰撞的则是它的实际矩阵边界，而不是原型本身设定的边界，这就导致它无法实现非矩阵精灵的物理场景。此外它支持摩擦力、重力、弹跳、加速等物理属性，适合应用精度要求不高，较为简单的游戏物理场景中。（例子：摘星星使用了重叠和碰撞）。

`Ninja Physics`（忍者物理系统）允许使用复杂的砖块和坡度，特别适合水平舞台。`Arcade Physics`不适合旋转物理精灵，`Ninja Physics`弥补了它的缺陷，可以处理物理旋转，`Ninja Physics`可以使精灵倾斜和复杂的平铺，这是更加灵活（可能更准确）的物理模型，但缺点是计算比较慢。

`P2 Physics`是一个全身物理系统，具有约束，弹簧，多边形支撑等。如果游戏需要对弹簧力的约束（例如：摆钟左右摇晃摆动）以及任意多边形形状（例如：四面体）进行建模，它更符合需求。（例子：红包雨使用到了四面体建模，愤怒的小鸟使用到了弹簧和多面体建模）

假如游戏中不需要用到复杂的物理动作，完全可以直接使用`Arcade Physics`，它使用简单，计算简单，性能消耗低。其他两个物理系统物理属性更为复杂且功能丰富，以性能消耗为代价。

### 物理属性

三个物理系统的物理属性API有些许差异，下面来介绍一下。

每一种物理属性需要在create阶段启动，确保精灵创建之前能被分配到指定物理系统，否则会出现错误。

> 下面代码以arcade为例。
>
> 如使用p2则改为：game.physics.startSystem(Phaser.Physics.P2JS);
>
> 如使用Ninja则为：game.physics.startSystem(Phaser.Physics.Ninja);

```javascript
const game=new Phaser.Game();

//开启物理引擎
game.physics.startSystem(Phaser.Physics.ARCADE);

const sprite=game.add.sprite();

//在sprite上启用arcade物理引擎
game.physics.enable(sprite,Phaser.Physics.ARCADE);

```

#### Arcade物理属性

速度velocity属性。

```javascript
sprite.body.velocity=new Phaser.Point(50,50)

sprite.body.velocity.set(50)

sprite.body.velocity.x=50;  //X轴的速度（正数往右，负数往左）

sprite.body.velocity.y=50;  //Y轴的速度（正数往下，负数往上）
```

加速度acceleration属性。

```javascript
sprite.body.acceleration=new Phaser.Point(50,50)  

sprite.body.acceleration.set(50)  

sprite.body.acceleration.x=50; //X轴的加速度

sprite.body.acceleration.y=50; //Y轴的加速度
```

阻力drag

```javascript
sprite.body.drag=new Phaser.Point(50,50);

sprite.body.drag.set(50)

sprite.body.drag.x=50;

sprite.body.drag.y=50;
```

重力gravity

```javascript
sprite.body.gravity=new Phaser.Point(50,50)

sprite.body.gravity.set(50)

sprite.body.gravity.x=50;

sprite.body.gravity.y=50;
```

弹跳bounce

```javascript
sprite.body.bounce=new Phaser.Point(50,50)

sprite.body.bounce.set(0.5)

sprite.body.bounce.x=0.5;

srpite.body.bounce.y=0.5
```

其他属性

```javascript
sprite.body.friction.set(100) //设置与其他物体接触时的摩擦力

sprite.body.rotation=Math.PI  //设置角度

sprite.body.immovable=true //设置该物体是固定的（true）还是不固定的（false）

sprite.body.mass=10 //设置物体的相对质量，默认为1

sprite.body.maxVelocity.set(100,200)  //设置最大速度

sprite.body.maxAngular=1000;  //设置最大角速度

sprite.body.setSize(width,height,offsetX,offsetY);  //设置body的范围

sprite.body.reset(x,y)  //重置所有的物理属性

sprite.body.touching.down 
sprite.body.touching.up  // 返回true/false，该物体的底部或顶部是否与其他物体接触
```

#### Arcade碰撞

arcade只支持AABB（矩形）之间的碰撞检测，并且`overlap`方法不产生效果，所以，应该使用`collide`方法。

```javascript
const game=new Phaser.Game()
const sprite1=game.add.sprite()
const sprite2=game.add.sprite()

game.physics.arcade.collide(sprite1,sprite2,null,function(){
  // collide方法不仅会检测两个物体之间的碰撞，而且会产生碰撞的物理效果，而overlap不会产生碰撞效果
})
```

精灵与组的碰撞（摘星星游戏就是使用了这个碰撞方案）

```javascript
const game=new Phaser.Game()
const sprite=game.add.sprite()
const group=game.add.group()

//检测精灵与组之间的碰撞
game.physics.arcade.collide(sprite,group)
```

组和组的碰撞

```javascript
const game=new Phaser.Game()
const group=game.add.group()

//检测组内的元素的碰撞
game.physics.arcade.collide(group)
```

#### P2物理属性

重力和速度

```javascript
game.physics.p2.gravity.y=50   // 给所有物体添加重力加速度
```

摩擦力

```javascript
game.physics.p2.friction=1   // 碰撞物体间的摩擦力
```

碰撞恢复

```javascript
game.physics.p2.restitution=0.8  // 碰撞物体间的恢复系数
```

碰撞检测

```javascript
// 启动p2物理系统
game.physics.startSystem(Phaser.Phaser.P2JS)

// 打开影响事件的世界，如果没有设置为true，我们不能得到碰撞回调   
game.physics.p2.setImpactEvents(true);

//创建碰撞组
const collisionGroup1=game.physics.p2.createCollisionGroup();
const collisionGtoup2=game.physics.p2.createCollisionGroup();

// 如果我们监听自己的碰撞，必须调用此来更新碰撞组
game.physics.p2.updateBoundsCollisionGroup()

const sprite1=game.add.sprite();
const sprite2=game.add.sprite()

// 保证物体启动物理特性
game.physics.p2.enable(sprite1);   

//给物体添加collisionGroup1碰撞组 
sprite1.body.setCollisionGroup(collisionGroup1)  
sprite1.body.collides(collisionGroup2);
```

#### Ninja物理属性

`Ninja`的属性特别多，不仅包含了`Arcade`的所有属性，额外多出来好几十种物理属性，所以这里不做一一介绍了，可以参考[Ninjs物理属性列表](https://www.w3cschool.cn/doc_phaser/phaser-phaser-physics-ninja.html?lang=en)。

## Sprite和Group用作容器的异同

我们经常会用到容器的概念，在Phaser中，最常用作容器的就是`Group`和`Sprite`。`Word`就是游戏中最底层的一个容器。

### 添加子对象的方法

`Sprite`常用方法是`addChild()`

`Group`添加子对象的方法很多个，如`add()`、`addChild()`、`create()`

### 两者都继承了DisplayObjectContainer

`Sprite`和`Group`的容器功能都继承自`DisplayObjectContainer`，但`DisplayObjectContainer`的一些原有的属性方法在`Sprite`中被重写了，比如`width`、`height`、`getBounds()`等；而`Group`则完整的继承了`DisplayObjectContainer`的属性方法，如果单纯作为容器使用，`Group`应该更合适，更专业。

### 关于TextTure和层级关系

`Sprite`有自己的`texture`，显示内容将会在它所有`children`的最底层，相当于背景（根据先画的垫底，后画的在上的渲染规则，以及先有父才有子的关系，所以不难理解） 

而`Group` 没有自己的`texture`，他只是一个纯容器，如同空气没有显示的东西，所以他自身跟`children`没有显示上的层级关系，只有`children`们各自之间的层级关系。

### 与Children的关系

`Sprite`作为容器，它的child一般是一个整体的一部分，比如一个飞机，可以有机身、机翼、螺旋桨，如果这些都是单独的素材，那么我们可以把飞机定义为一个`Sprite`，然后机身、机翼、螺旋桨作为它的孩子，通过`addChild`来加入。它的特点是共享父精灵的物理属性（比如位移、旋转），并且它们之间的相对位置固定。

如果是一群飞机，这时候我们建议使用`Group`，每一个飞机都是独立个体，有自己的位移、旋转等，并且它们的相对位置并不固定，有时可以挨得很近，有时可以离得很远。

## 解决低端设备卡顿的问题

在低端的设计处理速度会比较慢，容易造成视觉卡顿现象。

在Phaser中，可以通过设置`game.time.desiredFps`来解决，这个默认值是60FPS，但是在一些低端手机，会有些高，需要对游戏进行降频，降到30FPS。

解决的方案是在一秒钟内计算`update`被调动的次数，如果很低，那么就调整`game.time.desiredFps`的值。

```javascript
// 一秒内刷新
game.time.events.loop(Phaser.Timer.SECOND,this.checkoutFPS,this);

// 检查fps帧率
function checkoutFPS(){
  if(isSetTps) return
  if(this.fpsTestEnd){
    if(fpsCount >= 30){
      game.time.desiredFps = 60
    } else {
      game.time.desiredFps = fpsCount + 5
      isSetTps = true
    }
  } else {
    fpsCount++;
  }
}
```

## Sprite层级

`sprite`的层级是由`sprite`创建顺序决定的，`sprite`创建顺序越往后层级越高（越在上面）。

可能有人有这样的场景，后面的是动态添加的，只能后添加，却希望它在最底层。那么这时候只需要调用`sprite`中的`bringToTop`，它可以将某一个`sprite`拉到最高层。

同理，还有`sendToBack`，它可以将精灵放到最低层。

但是要注意，通过这种方式调整层级顺序，精灵必须位于同一个组内，也就是他们互为兄弟节点。

## 总结

以上是在游戏开发过程遇到的问题，以及最后的解决方案。

开发游戏是一个艰辛而又有乐趣的过程，享受游戏一步一步制作的乐趣，它不像软件应用，做出来各个流程体验一下就过去了，游戏可以反复把玩，设定各种难度和关卡，一步一步登天。

## 参考文献

[phaser社区](http://club.phaser-china.com/?tab=good)