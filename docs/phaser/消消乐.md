# 消消乐

## 前言

上次学习了phaser的基本使用，并且写了一个摘星星的游戏，颇为有趣。对phaser的场景、画布、精灵、物理引擎有了深入的认识。

想起在深圳实习的时候，挤地铁上下班期间经常看到有人在玩消消乐游戏，那咱们也来实现一个消消乐游戏。

## 目标

消消乐支持PC端玩耍，也支持手机端玩耍，游戏尺寸能够适配各种移动设备。

**游戏规则**

* x轴或者y轴连续3个格子相同即可被消除
* 消除之后随机补充格子
* 游戏有关卡机制，每关游戏时长为10秒钟
* 从第二关开始，每过一关新增两个障碍物

## 消消乐游戏

这里以phaser2版本作为游戏开发基础。

## 游戏核心概括

![游戏核心概括图](https://pic2.zhimg.com/80/v2-25f99bcb0c93f859896ab7329a7f9dbd_720w.png)

### 游戏环境搭建

消消乐游戏相比于摘星星来说复杂很多，这里将html和js分离，有利于更好的开发和维护。

```html
<!DOCTYPE html>
<html>

<head>
  <style type="text/css">
    body {
      background: #000000;
      padding: 0px;
      margin: 0px;
    }
  </style>
  <script src="phaser.js"></script>
  <script src="game.js"></script>
</head>

<body>
</body>

</html>
```

总共有两个JavaScript文件，一个的`phaser.js`引擎文件，需要放在上面，下面的`game.js`是游戏开发文件。

页面加载完毕后开始创建并执行游戏。

```javascript
let game;

// 游戏的基本配置信息，用于创建游戏画布
const gameOptions = {
  gameWidth: 800,    // 游戏宽度，以像素为单位
  gameHeight: 1300,   // 游戏高低，以像素为单位
  tileSize: 100,     // 瓦片（一个格子）的尺寸，以像素为单位
  fieldSize: 8, // 场地大小，场地应该是正方形的，这样才能流畅地进行游戏，这里设置为 8 X 8 的矩阵
  colors: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00], // 瓦片（格子）的颜色
  tiles: ['dog', 'cat', 'gh', 'tu'] // 四种格子元素
}
  
// 让它在页面加载后执行
window.onload = function () {

  // 使用Phaser引擎创建一个游戏
  game = new Phaser.Game(gameOptions.gameWidth, gameOptions.gameHeight);

  // 添加游戏
  game.state.add("TheGame", TheGame);

  // 启动游戏
  game.state.start("TheGame");
}

```

把游戏添加到`state`场景中，然后将场景中的游戏启动。

> `phaser2`的场景函数是`state`，`phaser3`的场景函数为`scene`，这里有一点点区别。

### 预加载资源

`Phaser`提供了资源加载的监听函数`this.load.on`, 有两个参数，第一个参数是监听的函数名称，第二个参数是回调函数，回调函数携带一个进度参数，值为0到1，一般我们会使用百分比的形式展示进度情况。

监听加载进度的代码如下：

```javascript
this.load.on('progress', value => {
    //value 是个0-1的浮点数
});
```

搭建舞台场景，设置舞台的背景色（后面添加背景图会覆盖掉）。

加载瓦片的资源，游戏中用到所有资源在此逐一加载。

```javascript
// 资源预加载，会在phaser预加载期间执行，可以实时监控资源加载的进度
preload() {

  // 设置舞台背景色
  game.stage.backgroundColor = 0x222222;

  // 加载瓦片资源
  game.load.spritesheet("tiles", "./assets/tiles.png", gameOptions.tileSize, gameOptions.tileSize);
  game.load.spritesheet("cat", "./assets/mao.png", gameOptions.tileSize, gameOptions.tileSize);
  game.load.spritesheet("dog", "./assets/gou.png", gameOptions.tileSize, gameOptions.tileSize);
  game.load.spritesheet("chicken", "./assets/ji.png", gameOptions.tileSize, gameOptions.tileSize);
  game.load.spritesheet("tu", "./assets/tu.png", gameOptions.tileSize, gameOptions.tileSize);
  game.load.spritesheet("gh", "./assets/gh.png", gameOptions.tileSize, gameOptions.tileSize);

  // 加载按钮资源
  game.load.image('button', "./assets/anniu.png")

  // 加载背景资源
  game.load.image('bg', "./assets/bg.png")
  game.load.image('bg1', "./assets/bg1.png")
  game.load.image('bg2', "./assets/bg2.png")

}
```

### 创建游戏画布

创建游戏画布，在游戏完全加载后立即执行。

这里可以设置画布的比例，以及适配方案，官网提供了五种画布适配的方案

* [.EXACT_FIT](https://phaser.io/docs/2.4.4/Phaser.ScaleManager.html#.EXACT_FIT) ：扩展内容以填充所有可用空间的比例模式
* [.NO_SCALE](https://phaser.io/docs/2.4.4/Phaser.ScaleManager.html#.NO_SCALE)：一种防止任何缩放的缩放模式
* [.RESIZE](https://phaser.io/docs/2.4.4/Phaser.ScaleManager.html#.RESIZE)：导致游戏大小改变的缩放模式
* [.SHOW_ALL](https://phaser.io/docs/2.4.4/Phaser.ScaleManager.html#.SHOW_ALL)：缩放模式，在保持比例的同时显示整个游戏
* [.USER_SCALE](https://phaser.io/docs/2.4.4/Phaser.ScaleManager.html#.USER_SCALE)：一种允许自定义比例设置的自定义模式

这里，我选择了全尺寸适配方案（SHOW_ALL），直接铺满整个游戏，同时让游戏水平居中。

舞台布置完毕，去创建游戏元素，和游戏关卡。

```javascript
  // 创建游戏画布，在游戏完全加载后立即执行
  create() {

    // 将游戏覆盖整个屏幕，同时保持其比例
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;

    // 游戏水平居中
    game.scale.pageAlignHorizontally = true;

    // 游戏垂直居中
    game.scale.pageAlignVertically = true;

    // 创建游戏
    this.createMatrix();
    this.tileGroup.visible = false
    this.canPick = false
    this.finishAnimation = true
    // 创建关卡
    this.createLevel()
  }
```

### 创建游戏元素

```javascript
  // 创建游戏元素
  createMatrix() {

    // canPick告诉我们，如果我们可以选择一个贴图，我们从“true”开始，有一个贴图可以被选择
    this.canPick = true;

    // tiles保存在一个名为tilesArray的数组中
    this.tilesArray = [];

    const bg = game.add.tileSprite(0, 0, game.width, game.height, 'bg1');
    bg.tint = 0xcccccc

    // 这个组将包含所有的贴图
    this.tileGroup = game.add.group();

    // 用来存储存所有瓦片格子的位置
    this.specialItemCandidates = [];

    // 矩阵的网格，由x轴和y轴组成，矩阵的x轴和y轴数量由gameOptions的x和y构成
    for (let i = 0; i < gameOptions.fieldSize; i++) {
      this.tilesArray[i] = [];
      for (let j = 0; j < gameOptions.fieldSize; j++) {

        // 创建格子元素
        this.addTile(i, j);

        // 将每个坐标添加到数组中
        this.specialItemCandidates.push(new Phaser.Point(j, i));
      }
    }

    // 随机选择一个位置放置障碍物
    this.heroLocation = Phaser.ArrayUtils.removeRandomItem(this.specialItemCandidates);

    // 调整画布
    this.tilesArray[this.heroLocation.y][this.heroLocation.x].tileSprite.frame = _HERO;

    // 调整格子的值。我们可以通过给帧添加10来定义特殊的贴图值
    // this.tilesArray[this.heroLocation.y][this.heroLocation.x].value = 10 + _HERO;

    // 我们还必须通过应用白色着色来去除着色
    this.tilesArray[this.heroLocation.y][this.heroLocation.x].tileSprite.tint = 0xffffff;

    // 我们在画布中以水平和垂直方式居中
    const fieldWidth = gameOptions.tileSize * gameOptions.fieldSize;

    // 将组放在画布的中间
    this.tileGroup.x = (game.width - fieldWidth) / 2;
    this.tileGroup.y = (game.height - fieldWidth) / 2;

    // 设置组，让它的焦点保持在重点位置
    this.tileGroup.pivot.set(fieldWidth / 2, fieldWidth / 2);

    // 调整分组位置，使其保持在之前分配的位置
    this.tileGroup.position.set(this.tileGroup.x + this.tileGroup.pivot.x, this.tileGroup.y + this.tileGroup.pivot.y);

    // 我们将绘制一个蒙版来隐藏从上面落下的方块。蒙版需要有相同的大小和位置的组
    this.tileMask = game.add.graphics(this.tileGroup.x - this.tileGroup.pivot.x, this.tileGroup.y - this.tileGroup.pivot.y);
    this.tileMask.beginFill(0xffffff);
    this.tileMask.drawRect(0, 0, fieldWidth, fieldWidth);
    this.tileGroup.mask = this.tileMask;
    this.tileMask.visible = false;

    // 它将包含被回收的已移除的格子
    this.tilePool = [];

    // 添加一个分数文案，记录分数
    this.score = 0
    this.scoreText = game.add.text(game.world.centerX, 80, `${this.score}分`, { font: "70px serif", fill: "#ffffff", align: "center", fontWeight: "bold" })
    // 设置锚点居中
    this.scoreText.anchor.set(0.5, 0.5)

    // 添加一个倒计时
    this.gameTime = _GAMETIME
    // 倒计时文案
    this.gameTimeText = game.add.text(game.world.centerX, 150, `倒计时：${this.gameTime}`, { font: "45px serif", fill: "#ffffff", align: "center" })
    // 设置锚点居中
    this.gameTimeText.anchor.set(0.5, 0.5)

    // 游戏关卡
    this.gameLevelText = game.add.text(game.world.centerX, 1200, `第${this.levelCount || 1}关`, { font: "45px serif", fill: "#ffffff", align: "center" })
    // 设置锚点居中
    this.gameLevelText.anchor.set(0.5, 0.5)

    // 玩家点击事件
    game.input.onDown.add(this.pickTile, this);
  }
```

### 创建格子元素

矩阵中的每个格子由`sprite`瓦片创建。`sprite`瓦片创建时第三个参数为字符串`key`,可以是`peload`函数中加载的资源所提供的`key`值，因此我们可以利用随机值，从`'dog', 'cat', 'gh', 'tu'`中随便挑选一张即可。

```javascript
  // 创建消消乐水平和垂直给格子的画布图
  addTile(row, col) {

    // 根据瓦片大小确定x轴和y轴瓦片位置
    const tileXPos = col * gameOptions.tileSize + gameOptions.tileSize / 2;
    const tileYPos = row * gameOptions.tileSize + gameOptions.tileSize / 2;

    // 给格子分配一个随机值，通过这个值来检查是否属于同类
    const tileValue = game.rnd.integerInRange(0, gameOptions.tiles.length - 1);

    // 创建一个由图片制作的瓦片
    const theTile = game.add.sprite(tileXPos, tileYPos, gameOptions.tiles[tileValue]);

    // 设置贴图的注册点到它的中心
    theTile.anchor.set(0.5);

    // 根据瓦片的大小调整瓦片的宽度和高度
    theTile.width = gameOptions.tileSize;
    theTile.height = gameOptions.tileSize;

    // 设置填充色
    // theTile.tint = gameOptions.tiles[tileValue];

    // 创建一个数组，图像收集到tilesArray数组内
    // 最终形成的就是我们看到的整体布局
    this.tilesArray[row][col] = {
      tileSprite: theTile, // 画布图像，格子
      isEmpty: false, // 判断在矩阵的当前位置是否为空（被消掉），为空则创建新的瓦片填充进来
      coordinate: new Phaser.Point(col, row), // 存储瓦片坐标，在新的瓦片填充期间有用
      value: tileValue // 瓦片的值
    };

    // 并将其添加到格子数组
    this.tileGroup.add(theTile);
  }
```

### 创建游戏关卡

游戏关卡展示窗口布满整个屏幕，我选择了一张可爱的图片，直接平铺，在页面中间展示关卡信息。

```javascript
  // 创建关卡
  createLevel() {
    // 关卡元素组合
    this.levelGroup = game.add.group()

    const levelBg = game.add.tileSprite(0, 0, game.width, game.height, 'bg');
    levelBg.tint = 0xe4e4e4
    // 关卡等级
    this.levelCount = 1
    // 关卡显示文案
    const levelTextStyle = { font: "120px serif", fill: "#ffffff", align: "center" }
    this.levelText = game.add.text(game.world.centerX, game.world.centerY - 140, `第${this.levelCount}关`, levelTextStyle)
    // 设置锚点居中
    this.levelText.anchor.set(0.5, 0.5)
    // 关卡
    const levelDesStyle = { font: "60px serif", fill: "#ffffff", align: "center", fontWeight: "bold" }
    this.levelDes = game.add.text(game.world.centerX, game.world.centerY, _LEVEL[this.levelCount], levelDesStyle)
    this.levelDes.anchor.set(0.5, 0.5)
    // 开始按钮背景
    const button = game.add.button(game.world.centerX, game.world.centerY + 100, "button", function () {
      // 显示游戏矩阵视图
      this.tileGroup.visible = true
      // 启动倒计时
      this.setGameTimer()
      // 隐藏关卡展示
      this.levelGroup.visible = false
      // 500毫秒之后才可以点击，防止玩家手速过快，点击确认就立马被触发
      setTimeout(() => {
        this.canPick = true
      }, 500);
    }, this);
    button.anchor.set(0.5, 0)
    // 按钮文字
    const startText = game.add.text(game.world.centerX, game.world.centerY + 145, "开始游戏", { font: "30px serif", fill: "#ffffff", align: "center" })
    startText.anchor.set(0.5, 0.5)

    // 将上面元素都添加都这个组里面，统一管理
    this.levelGroup.add(levelBg)
    this.levelGroup.add(this.levelText)
    this.levelGroup.add(this.levelDes)
    this.levelGroup.add(button)
    this.levelGroup.add(startText)
  }
```

### 计时器

每一个关卡有十秒钟的游戏时长，从10开始逐渐递减。

```javascript
  // 计时器，关卡累加器
  setGameTimer() {
    this.gameTimer = setInterval(() => {
      if (this.gameTime > 0) {
        this.gameTime -= 1
        this.gameTimeText.text = `倒计时：${this.gameTime}`
      } else {
        // 动画未执行完毕，直接退出
        if (!this.finishAnimation) return
        this.replayGame()
      }
    }, 1000);
  }
```

### 下一关，继续游戏

当游戏时长为0，则切换到关卡窗口，把游戏矩阵隐藏掉。等待玩家在游戏关卡窗口点击，继续游戏操作。

从第二关开始，没关递增两个障碍物，障碍物是不可以点击的。

为增加游戏乐趣，每一关给个提示语，总共给十个提示语：

>   1: '一马当先',
>
>   2: '二横开泰',
>
>   3: '三生有幸',
>
>   4: '四季如春',
>
>   5: '五福东海',
>
>   6: '六六大顺',
>
>   7: '七嘴八舌',
>
>   8: '八仙过海',
>
>   9: '九九归一',
>
>   10: '十分顺利'

```javascript
  // 重新开始游戏
  replayGame() {
    this.canPick = false
    this.levelGroup.visible = true
    this.levelCount += 1
    this.levelText.text = `第${this.levelCount}关`
    this.levelDes.text = _LEVEL[this.levelCount] || '天下无敌，你最牛逼'
    this.gameLevelText.text = `第${this.levelCount}关`
    this.tileGroup.visible = false
    clearInterval(this.gameTimer)
    // 重置倒计时时间
    this.gameTime = _GAMETIME
    this.gameTimeText.text = `倒计时：${this.gameTime}`
  }
```

### 障碍物

设置障碍物不可点击。其次为了让用户知道哪些是障碍物，给它填充成为黑色，直接黑化。

```javascript
replayGame(){
  /** 省略 **/
  
  // 增加游戏难度，给两个障碍物
  if (this.score > this.levelCount * 10 && this.levelCount <= 10) {
    // 随机选取元素（这其中会包含重复的value）
    do {
      var keyLocation = Phaser.ArrayUtils.removeRandomItem(this.specialItemCandidates);
    } while (this.isAdjacent(this.heroLocation, keyLocation));
    this.tilesArray[keyLocation.y][keyLocation.x].tileSprite.frame = _KEY;
    this.tilesArray[keyLocation.y][keyLocation.x].value = 10 + _KEY; // 设置为独立的key，让它不被同类型格子元素销毁
    this.tilesArray[keyLocation.y][keyLocation.x].tileSprite.tint = 0x000000; // 设置背景会黑色（黑化）
  }
}
```

### 点击格子

静态游戏画布搭建完毕，咱们开始玩游戏啦~

```javascript
  // 在玩家点击或触摸时执行
  pickTile(e) {

    // 判断是否可以点击，在瓦片还在填充期间是不可以点击的
    if (this.canPick) {

      // 确定tileGroup内触摸的x和y位置
      const posX = e.x - this.tileGroup.x + gameOptions.tileSize * gameOptions.fieldSize / 2;
      const posY = e.y - this.tileGroup.y + gameOptions.tileSize * gameOptions.fieldSize / 2;

      // 将坐标转换为实际的行和列
      const pickedRow = Math.floor(posY / gameOptions.tileSize);
      const pickedCol = Math.floor(posX / gameOptions.tileSize);

      // 检查行和列是否在实际的游戏领域内
      if (pickedRow >= 0 && pickedCol >= 0 && pickedRow < gameOptions.fieldSize && pickedCol < gameOptions.fieldSize) {

        // 选中的格子
        const pickedTile = this.tilesArray[pickedRow][pickedCol];

        this.filled = [];
        this.filled.length = 0;

        // 在选定的格子上执行填充
        this.floodFill(pickedTile.coordinate, pickedTile.value);

        // x轴和y轴相关联的数量至少要3个才执行消除操作，这里可以设置
        if (this.filled.length > 2) {

          // 玩家将不能点击其他的格子，直到所有的动画播放完毕
          this.canPick = false;

          // 销毁选中的格子以及x轴y轴相关的格子
          this.destroyTiles();
        }
      }
    }
  }
```

### 递归检查格子四周

递归检查格子上下左右有没有相同值的，有的话就累加到`filled`数组中，用来计算数量。

```javascript
  // 递归遍历查看x轴和y轴是否有相同值的元素
  floodFill(p, n) {
    if (p.x < 0 || p.y < 0 || p.x >= gameOptions.fieldSize || p.y >= gameOptions.fieldSize) {
      return;
    }
    if (!this.tilesArray[p.y][p.x].isEmpty && this.tilesArray[p.y][p.x].value == n && !this.pointInArray(p)) {
      this.filled.push(p);
      this.floodFill(new Phaser.Point(p.x + 1, p.y), n);
      this.floodFill(new Phaser.Point(p.x - 1, p.y), n);
      this.floodFill(new Phaser.Point(p.x, p.y + 1), n);
      this.floodFill(new Phaser.Point(p.x, p.y - 1), n);
    }
  }
```

### 超过三个相同格子，执行销毁

递归检查完毕四周，有超过三个以上的格子是相同的，需要将选中的所有格子元素销毁。

销毁的过程，给它一点动画效果，从透明度1到0，动画时长0.3秒。

```javascript
  // 这个函数将会销毁我们选中的所有格子
  destroyTiles() {
    this.finishAnimation = false
    // 循环遍历数组，逐个删除所有元素
    do {
      // 移除数组的第一个格子元素
      const element = this.filled.shift();

      // 给格子销毁渐变动画
      const tween = game.add.tween(this.tilesArray[element.y][element.x].tileSprite).to({
        alpha: 0
      }, 300, Phaser.Easing.Linear.None, true);

      // placing the sprite in the array of sprites to be recycled
      this.tilePool.push(this.tilesArray[element.y][element.x].tileSprite);

      // 当补间动画执行完毕
      tween.onComplete.add(function (e) {

        // 重置补间动画
        e.frame = 0

        // 我们不知道我们已经删除了多少个格子，所以计算当前正在使用的补间是一个好方法
        // 我们假设，这是最后一个补间 (只有一个补间在运行)
        if (tween.manager.getAll().length == 1) {

          // 执行格子下降动画
          this.fillVerticalHoles();
        }
      }, this);

      // 现在格子是空的
      this.tilesArray[element.y][element.x].isEmpty = true;

      // 我们将重复这个循环，直到有东西填充进数组
    } while (this.filled.length > 0)
  }
```

### 填充被销毁的格子

格子销毁掉，接下来要创建新的格子去填充留空的位置。

```javascript
  // 这个函数负责让新的格子落下来
  fillVerticalHoles() {

    // 定义个变量，用来告诉我们是否填满了被销毁的格子位置
    var filled = false;

    for (var i = gameOptions.fieldSize - 2; i >= 0; i--) {
      for (var j = 0; j < gameOptions.fieldSize; j++) {

        // 如果格子不为空
        if (!this.tilesArray[i][j].isEmpty) {

          // 让我们数一下在这块瓷砖下面能找到多少个空的坐标位置
          var holesBelow = this.countSpacesBelow(i, j);

          // 如果留空的位置大于零
          if (holesBelow) {

            // 我们填了一个留空的位置，要处理一下它
            filled = true;

            // 函数将列“j”的平铺从“i”移到“i + holesBelow”行
            this.moveDownTile(i, j, i + holesBelow, false);
          }
        }
      }
    }

    // 如果遍历所有的格子，没有完全填充满，则结束执行
    if (!filled) {

      // 动画执行完毕
      this.endMove();
    }

    // 现在是时候重用池中保存的tiles (tilePool数组)了，让我们从遍历每一列开始
    for (i = 0; i < gameOptions.fieldSize; i++) {

      // 计算每一列有多少空格
      const topHoles = this.countSpacesBelow(-1, i);

      // 然后遍历每一个空格
      for (j = topHoles - 1; j >= 0; j--) {

        // 设置随机值
        const tileValue = game.rnd.integerInRange(0, gameOptions.tiles.length - 1);

        // 让它下落到留空的y轴
        const tileYPos = (j - topHoles) * gameOptions.tileSize + gameOptions.tileSize / 2 - 100;
        // x轴
        const tileXPos = i * gameOptions.tileSize + gameOptions.tileSize / 2;

        // 随机创建新的格子元素
        const reusedTile = game.add.sprite(tileXPos, tileYPos, gameOptions.tiles[tileValue]);

        // 设置格子的注册点到它的中心
        reusedTile.anchor.set(0.5);

        // 根据瓦片的大小调整瓦片的宽度和高度
        reusedTile.width = gameOptions.tileSize;
        reusedTile.height = gameOptions.tileSize;

        // 填充背景色
        // reusedTile.tint = gameOptions.tiles[tileValue];

        // 设置新的格子元素
        this.tilesArray[j][i] = {
          tileSprite: reusedTile,
          isEmpty: false,
          coordinate: new Phaser.Point(i, j),
          value: tileValue
        }

        // 添加到格子数组中，目的是为了让格子滑动的位置基于格子矩阵顶部水平线
        this.tileGroup.add(reusedTile)

        // 让格子移动到下面，并且填充到指定位置
        this.moveDownTile(0, i, j, true);
      }
    }
  }
```

### 下落动画

填充的过程也需要给个动画效果，咱们就让它从上往下落下吧~

```javascript
  // 向下移动铺满被消除的格子位置
  moveDownTile(fromRow, fromCol, toRow, justMove) {

    // 一个格子可以只是移动(当它是一个“新的”格子从上面落下)
    // 必须移动更新游戏画布位置(当它是一个“旧”格子从之前的位置下降)，justMove标志处理此操作
    if (!justMove) {

      // 将格子本身及其值保存在临时变量中
      const tileToMove = this.tilesArray[fromRow][fromCol].tileSprite;
      const tileValue = this.tilesArray[fromRow][fromCol].value;

      // 调整格子数组，在新的位置创建格子
      this.tilesArray[toRow][fromCol] = {
        tileSprite: tileToMove,
        isEmpty: false,
        coordinate: new Phaser.Point(fromCol, toRow),
        value: tileValue
      }

      // 旧的的位置现在设置为空
      this.tilesArray[fromRow][fromCol].isEmpty = true;
    }

    // 移动的距离，以像素为单位（以此作为动画时长的值）
    const distanceToTravel = (toRow * gameOptions.tileSize + gameOptions.tileSize / 2) - this.tilesArray[toRow][fromCol].tileSprite.y

    // 每个格子都有独立的补间动画效果
    const tween = game.add.tween(this.tilesArray[toRow][fromCol].tileSprite).to({
      y: toRow * gameOptions.tileSize + gameOptions.tileSize / 2
    }, distanceToTravel / 2, Phaser.Easing.Linear.None, true);

    // 看看有多少补间动画还在执行者，如果这是最后一个活动补间，格子的移动流程就完成了
    tween.onComplete.add(function () {
      if (tween.manager.getAll().length == 1) {
        // 分数累加，一次加 10
        this.score += 10
        // 改变画布视图的文案
        this.scoreText.text = `${this.score}分`
        // 处理善后
        this.endMove();
        setTimeout(() => {
          // 设置完成动画
          this.finishAnimation = true
          // 计时器提前结束，进入关卡界面
          if (this.gameTime === 0) this.replayGame()
        }, 200);
      }
    }, this);
  }
```

## 总结

* 游戏格子矩阵使用双循环构建，组成8*8的矩阵网格
* 格子元素使用`sprite`生成
* 每个格子分配一个随机值，值由Phaser引擎`Phaser.rnd.integerInRange`提供
* 游戏障碍物是通过在格子矩阵中随机抽取其中一个，将其的value值设置成10~13（正常能消除的value值我0~3）
* 利用Phaser的`input`事件监听玩家点击操作，取其x轴和y轴的焦点去定位到具体的格子
* 递归扫描点击的格子四周是否有同等值格子，有则将其加入到filled数组中，数组长度判断是否执行销毁事件
* 格子销毁和格子填充均使用`tween`补间动画
* 游戏设置关卡机制，总共有十个关卡，每个关卡游戏时长10秒钟（游戏时长是可以根据需求设置的），十秒钟结束后切换至关卡确认页面，十关结束后玩家可以继续游玩

[在线玩耍地址](http://39.108.221.55:5100)

[代码仓库地址](https://gitee.com/smallzip/eliminate/tree/master)

[在线代码阅读](https://github1s.com/jianpiao/eliminate/blob/HEAD/game.js)

## 参考文献
[Phaser小站实例](https://www.phaser-china.com/example.html)
[Phaser从入门到精通](http://book.phaser-china.com/SPRITE.html)
[Phaser学习笔记](https://stonetingxin.gitbooks.io/phaser/content/fist___games/sprites.html)
[http-server](https://github.com/http-party/http-server)
