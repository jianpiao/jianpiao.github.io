(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{384:function(a,s,v){"use strict";v.r(s);var _=v(33),t=Object(_.a)({},(function(){var a=this,s=a.$createElement,v=a._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"mysql索引原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引原理"}},[a._v("#")]),a._v(" MySQL索引原理")]),a._v(" "),v("p",[a._v("学习MySQL数据库索引原理知识，同时了解与性能相关的优化实践。")]),a._v(" "),v("p",[a._v("讲述关于索引的原理，为后面数据库优化提供合适的方案。")]),a._v(" "),v("h2",{attrs:{id:"索引的本质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的本质"}},[a._v("#")]),a._v(" 索引的本质")]),a._v(" "),v("p",[a._v("mysql的索引做了合理的数据结构转换，查询庞大数据的情况下，极大的提高了效率。")]),a._v(" "),v("h3",{attrs:{id:"本质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本质"}},[a._v("#")]),a._v(" 本质")]),a._v(" "),v("p",[v("strong",[a._v("索引")]),a._v("是能够在MySQL对数据"),v("strong",[a._v("进行排序，"),v("strong",[a._v("生成新的")]),a._v("数据结构")]),a._v("，最终实现高效率查询数据的一种方式。总的来说，索引就是一种数据结构。")]),a._v(" "),v("h2",{attrs:{id:"索引底层结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引底层结构"}},[a._v("#")]),a._v(" 索引底层结构")]),a._v(" "),v("p",[a._v("索引的数据结构有如下几种：")]),a._v(" "),v("ul",[v("li",[a._v("二叉树")]),a._v(" "),v("li",[a._v("红黑树")]),a._v(" "),v("li",[a._v("Hash表")]),a._v(" "),v("li",[a._v("B-Tree")])]),a._v(" "),v("h3",{attrs:{id:"数据库查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库查询"}},[a._v("#")]),a._v(" 数据库查询")]),a._v(" "),v("p",[a._v("下面是一张数据库的表，有两列数据，分别是Col1和Col2，存储的都是数字。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-710ff9041781950cf6a6547a2424dcc6_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("我们来查询一下数字为89的数据，mysql语句如下：")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" s\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Col2 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("89")]),a._v("\n")])])]),v("p",[a._v("普通模式下，查询的规则是从上往下查询：")]),a._v(" "),v("p",[a._v("| 34  👇🏻")]),a._v(" "),v("p",[a._v("| 77  👇🏻\n| 5   👇🏻")]),a._v(" "),v("p",[a._v("| 91  👇🏻")]),a._v(" "),v("p",[a._v("| 22 👇🏻")]),a._v(" "),v("p",[a._v("| 98 👇🏻")]),a._v(" "),v("p",[a._v("终止查询")]),a._v(" "),v("p",[a._v("如果数据表很大，查询的数据又是在表尾的话，那么需要花费非常多的计算时间。")]),a._v(" "),v("p",[v("strong",[a._v("优化？")])]),a._v(" "),v("p",[a._v("那么有没有想过其他的优化方案呢，减少在有有序表中的计算？如果是单纯的数字比对，表中又有键值的话，我能想到的第一个就是算法中的二分查找。但是在这里是不适用的，因为数据是无序的。")]),a._v(" "),v("h3",{attrs:{id:"二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[a._v("#")]),a._v(" 二叉树")]),a._v(" "),v("p",[a._v("利用索引来实现优化，这里使用的"),v("strong",[a._v("二叉查找树")]),a._v("。")]),a._v(" "),v("p",[a._v("给Col2所有数据设置索引，给索引的每个节点是一个键值对（key/value），键保存的是所在行位置存储于磁盘的地址指针，value保存的是所在行位置的值。")]),a._v(" "),v("p",[a._v("例如：0x07：34")]),a._v(" "),v("p",[a._v("索引底层使用的数据结构是二叉树，最终存储的结构图如下：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-9e9a1ba1ac24f467b45009412ee7ae0f_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("如果我们再查询89的话，从根节点34开始查找，")]),a._v(" "),v("p",[a._v("| 34  👇🏻")]),a._v(" "),v("p",[a._v("| 89  👇🏻")]),a._v(" "),v("p",[a._v("终止查询")]),a._v(" "),v("p",[a._v("二叉树查询中，左边的子节点小于它的根节点，根节点小于右边的子节点。通过这个规律就可以很快的查找到对应的值。")]),a._v(" "),v("p",[a._v("效率得到了极大的提高，相比于原始的循序查询来说，减少很多不必要计算。但是索引底层用的并不是二叉树，因为二叉树对于有序列表来说是不能胜任的，我看下面的例子：")]),a._v(" "),v("h4",{attrs:{id:"有序查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有序查询"}},[a._v("#")]),a._v(" 有序查询")]),a._v(" "),v("p",[a._v("下面是是二叉树存储有序的数据，我们都知道二叉树右边的子节点是小于根节点的，所以，有序的数据最终排列的结构和链表差不多。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-36851efeca96bd544ba544e4f3a4adc6_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("我们查询6的结果是怎么样的呢？")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" s\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Col1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v("\n")])])]),v("p",[a._v("结果如下：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pica.zhimg.com/80/v2-9ab7a8f01a0a2f39ceee30014b53087b_720w.gif",alt:"12.gif"}})]),a._v(" "),v("p",[a._v("测试链接：https://www.cs.usfca.edu/~galles/visualization/BST.html")]),a._v(" "),v("p",[a._v("插入六个数字，可以看到查询的动画效果。")]),a._v(" "),v("p",[a._v("查询结果是，比对了六次才查找到最终结果，和原始查询并无差别，所以二叉树只在一定场景下有用。")]),a._v(" "),v("h3",{attrs:{id:"avl红黑树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#avl红黑树"}},[a._v("#")]),a._v(" AVL红黑树")]),a._v(" "),v("p",[a._v("二叉查找树存在不平衡的问题，那么可以通过树的叶子节点自动旋转和调整，让二叉树始终保持基本平衡的状态，这样就能够保持二叉查找树的最佳性能。基于以上思路的自调整平衡二叉树有"),v("strong",[a._v("AVL树和红黑树。")])]),a._v(" "),v("p",[a._v("红黑树是一颗自动调整树形态的树结构，当二叉树处于一个不平衡状态下时，红黑树会自动左右旋转叶子节点以及节点变色（红色或者黑色），调整树的形态，使其保持基本的平衡，这个时候如果是查询节点，时间复杂度为O(logn)，基本上保证了查找效率。使用二叉树插入七个节点，它的形态就如同一个链表，查询底部节点需要的时间复杂度达到了O(n)，而使用红黑树则会自动化调节树的形态，使其达到平衡状态。可见下图：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pica.zhimg.com/80/v2-55bdcf4e034966fb4e5e34f49f14faf1_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("如果上面的查询换成红黑树会是什么效果呢？")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" s\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Col1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v("\n")])])]),v("p",[a._v("查询过程：")]),a._v(" "),v("p",[a._v("| 2  👇🏻")]),a._v(" "),v("p",[a._v("| 4  👇🏻")]),a._v(" "),v("p",[a._v("| 6  👇🏻")]),a._v(" "),v("p",[a._v("终止查询")]),a._v(" "),v("p",[a._v("动画效果：")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://www.yuque.com/attachments/yuque/0/2021/gif/457751/1625450965712-bfc5cb14-ce37-481e-9592-b71bd8c8ea85.gif",target:"_blank",rel:"noopener noreferrer"}},[a._v("📎111.gif"),v("OutboundLink")],1)]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-553a9f1d5ee2382b70a4c4342e20f7c8_720w.gif",alt:"动画"}})]),a._v(" "),v("p",[a._v("通过上面的动画，可以看到，查询次数明显减少，效率上得到显著的提升。但是依旧还存在问题。")]),a._v(" "),v("ul",[v("li",[a._v("数据非常大的情况下，叶子节点太深了")]),a._v(" "),v("li",[a._v("每次查找叶子节点为一层，几十几百万层的查询，完全不可控")])]),a._v(" "),v("p",[a._v("上面7个节点的形态有一点点的规律，就是有一些向右倾斜，尽管没有二叉树倾斜的厉害，但是倾斜的幅度也是挺大的，而这个只是7个节点而已，那如果有几十万上百万个节点，倾斜的幅度是不可容忍的，倾斜幅度带来的问题的查找的深度。对于查找性能来说是巨大的消耗。")]),a._v(" "),v("p",[a._v("所以应对这个问题，有人考虑到了AVL树，相对于了红黑树来说，AVL树是严格意义上的**绝对平衡二叉树，**因此在调整二叉树的形态上消耗的性能更多。")]),a._v(" "),v("p",[a._v("下图为VAL树:")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-e5516e043fd419a3db21ae21ea42717e_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("相比于红黑树来说，节点的形态更加的平衡。按照层级来对比，红黑树有4层，AVL只有三层。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-a5b994adc2e2a8847c567557fd00daee_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("同样是查询节点6，结果会如何呢？")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" s\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Col1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v("\n")])])]),v("p",[a._v("查询过程：")]),a._v(" "),v("p",[a._v("| 4  👇🏻")]),a._v(" "),v("p",[a._v("| 6  👇🏻")]),a._v(" "),v("p",[a._v("终止查询")]),a._v(" "),v("p",[a._v("查询动画：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-8326574914b72666a8f6a2e3d37aa62d_720w.gif",alt:"13.gif"}})]),a._v(" "),v("p",[a._v("通过对比发现")]),a._v(" "),v("ul",[v("li",[a._v("叶子节点层级减少")]),a._v(" "),v("li",[a._v("解决向右倾斜的问题，形态上保持了平衡")]),a._v(" "),v("li",[a._v("查询效率提升，大量顺序插入不会导致查询性能的降低，从根本上解决了红黑树遇到的问题")])]),a._v(" "),v("p",[a._v("看起来AVL树作为数据查找的数据结构挺不错的，但是AVL树并没有被作为MySQL数据库的索引数据结构。因为数据库查找的瓶颈在于磁盘的I/O操作，如果使用AVL树，每一个树节点只存储一个数据，一次磁盘I/O只能读取一个节点的数据加载到内存中，假设依旧按照上面的查询6，则需要进行两次I/O操作，相比对内存计算来说，I/O操作是效率极低的，所以数据库索引首先考虑尽量减少频繁的I/O操作。")]),a._v(" "),v("p",[a._v("操作系统从上层到底层，各个层次之间存在着很多的I/O操作，比如CPU有I/O，内存有I/O，VMM有I/O，底层磁盘也有I/O。通常来说，一个上层的I/O可能会产生对磁盘的多个I/O，也就是说上层的I/O是稀疏的，底层的I/O是密集的。")]),a._v(" "),v("p",[a._v("这里我们只关注磁盘的 I/O，顾名思义就是磁盘的输入输出。输入指的是对磁盘写入数据，输出指的是从磁盘读出数据。磁盘读取10kb的数据和内存计算10kb的数据所消耗的时间的不一样的，磁盘读取所消耗的时间会比内存更长（感兴趣可以了解一下磁盘I/O性能指标，和CPU计算性能指标）。根据这个特性，可以在每一个节点中尽可能多的存储一些数据，一次磁盘I/O就多家在一些数据到内存中，这个就是B+树的设计原理。")]),a._v(" "),v("h3",{attrs:{id:"b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[a._v("#")]),a._v(" B+树")]),a._v(" "),v("p",[a._v("B树是一种数据结构，它有如下特征")]),a._v(" "),v("ul",[v("li",[a._v("叶节点具有相同的深度，叶节点的指针为空")]),a._v(" "),v("li",[a._v("所有索引元素不重复")]),a._v(" "),v("li",[a._v("节点中的数据索引从左到右递增排列")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pica.zhimg.com/80/v2-848218f73dcf5f52d07bf0089af2a757_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("B树和B+树的区别：")]),a._v(" "),v("ul",[v("li",[a._v("非叶子节点不存储data，只存储索引，可以放更多的索引")]),a._v(" "),v("li",[a._v("叶子结点包含所有索引字段")]),a._v(" "),v("li",[a._v("叶子节点用指针链接（链表链接），提高区间访问的性能")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-5e471427586737c3d2f544045d5a2e6b_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("B+树中的根节点有15、56、77，在15和56中间的白色是下一个节点的**磁盘文件地址。**除了根节点是存储在内存中之外，其他的子节点都是存储在磁盘中。当查询的值不在15~56范围区间内，且不是15也不是56的时候，会读取磁盘地址，拉取磁盘文件到内存中（这个过程俗称I/O操作，I/O操作速度是挺慢的），在内存中进行比对查找。因为内存的计算和I/O操作完全不是一个量级的，内存使用的RAM计算。")]),a._v(" "),v("h4",{attrs:{id:"数据存储量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据存储量"}},[a._v("#")]),a._v(" "),v("strong",[a._v("数据存储量")])]),a._v(" "),v("p",[a._v("想要计算MySQL数据存储量，首先就得知道根节点有多大，因为根节点的存储在内存中的，子节点才是存在磁盘中的，那么如何查看根节点的大小呢？")]),a._v(" "),v("p",[a._v("我们可以通过在Navicat Premium中进行sql语句的查询")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("show")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("GLOBAL")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("STATUS")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("like")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Innodb_page_size'")]),a._v("\n")])])]),v("p",[a._v("结果如下：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pica.zhimg.com/80/v2-0750aca25a43410e2aaff32689d811cc_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("最终查询到的大小是16kb。所以说MySQL设置一个节点最大是16kb。")]),a._v(" "),v("p",[a._v("一个节点的大小是8个字节，索引指针是6个字节（15~56中间白色的区域）")]),a._v(" "),v("p",[a._v("公式："),v("strong",[a._v("16kb / (8b+6b) = 1170")])]),a._v(" "),v("p",[a._v("所以，设置一个节点的话，最大可以存储1170个索引。")]),a._v(" "),v("p",[a._v("如果层级数为三层，即高度为3，那么可以存储多少数据呢？")]),a._v(" "),v("p",[a._v("公式："),v("strong",[a._v("1170 * 1170 * 1170  = 16亿（"),v("strong",[v("strong",[a._v("左右")])]),a._v("）")])]),a._v(" "),v("p",[a._v("哇，高度为三层，就可以存储怎么多是数据。那么如果查询的内容是20的话，只需要经过两次I/O操作，就可以查询到对应的值。")]),a._v(" "),v("h2",{attrs:{id:"myisam索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#myisam索引"}},[a._v("#")]),a._v(" MyISAM索引")]),a._v(" "),v("p",[a._v("MyLSAM索引文件和数据文件是分离的，即为"),v("strong",[a._v("非聚集索引")]),a._v("。下面讲解一下文件结构和数据结构")]),a._v(" "),v("p",[a._v("MyISAM的数据库一般是存在三个文件中的，分别是后缀为frm、MYD、MYI的文件，如下图：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pica.zhimg.com/80/v2-eaf306ffb05babc26328b937778bd99f_720w.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("每个文件的作用分别是：")]),a._v(" "),v("ul",[v("li",[a._v("frm：存储表结构相关的信息")]),a._v(" "),v("li",[a._v("MYD：表数据")]),a._v(" "),v("li",[a._v("MYI：表索引，就是我们建表时候是主键")])]),a._v(" "),v("p",[a._v("下面是索引的结构图：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-6183acd55c1c15a3d87ca5c0bd6db9a5_720w.png",alt:"image.png"}})]),a._v(" "),v("h3",{attrs:{id:"索引查询流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引查询流程"}},[a._v("#")]),a._v(" 索引查询流程")]),a._v(" "),v("p",[a._v("如果有一个查询：")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" s\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Col1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("30")]),a._v("\n")])])]),v("p",[a._v("如果使用的是索引查询，则会读第一个根节点，查找到30，它处于在15~56中间，则会进行一次I/O操作，进入到MYI文件中进行找到对应的索引，将读取的文件交给内存执行B+树查找，为没有找到数据则会进行第二次I/O操作，最终读取到了30这个索引值，索引值存储的是一个索引所在行的磁盘文件地址，这个地址是指向的MYD后缀文件，所以会进行I/O读取MYD后缀的数据表文件读取对应行的值。")]),a._v(" "),v("p",[a._v("以上就是MyISAM索引引擎底层搜索所经历的流程。")]),a._v(" "),v("h2",{attrs:{id:"innodb索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb索引"}},[a._v("#")]),a._v(" InnoDB索引")]),a._v(" "),v("p",[a._v("InnoDB索引文件是合在一起的，即索引和数据存在一个文件，因此它属于"),v("strong",[a._v("聚集索引")]),a._v("。")]),a._v(" "),v("p",[a._v("InnoDB的数据库一般存在两个文件中，分别是后缀为frm、ibd的文件，如下图：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/457751/1625466096900-3375d928-014d-4c8c-bf38-ab12878c3a38.png",alt:"image.png"}})]),a._v(" "),v("p",[a._v("每个文件的作用分别是：")]),a._v(" "),v("ul",[v("li",[a._v("frm：存储表结构相关信息")]),a._v(" "),v("li",[a._v("ibd：存储表的索引，和所有的数据")])]),a._v(" "),v("p",[a._v("下面是索引的结构图：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-b9f0bfce7c18da0176012776446e69d5_720w.png",alt:"image.png"}})]),a._v(" "),v("h3",{attrs:{id:"特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[a._v("#")]),a._v(" 特性")]),a._v(" "),v("ul",[v("li",[a._v("InnoDB的叶子节点存储的是每个索引所在行的所有数据字段，即所在行完整的数据。（参见最底层叶子节点索引15，下面是所在行的数据34、Bob）")]),a._v(" "),v("li",[a._v("表文件本身就是B+树组织的一个索引结构文件")]),a._v(" "),v("li",[a._v("由于主键和数据都是在一个文件内的，所有InnoDB必须要有主键，并且推荐使用整型的自增主键")]),a._v(" "),v("li",[a._v("非主键索引结构的叶子节点存储的是主键值，这个是为了实现一致性，节省存储的空间")])]),a._v(" "),v("h2",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),v("ul",[v("li",[a._v("索引底层使用的是B+Tree结构。")]),a._v(" "),v("li",[a._v("索引最底层的叶子节点是排好序的链表，可以访问左右相邻节点。")]),a._v(" "),v("li",[a._v("数据库类型有很多种，比如MyISAM、InnoDB，它们区别于聚集索引和非聚集索引。")]),a._v(" "),v("li",[a._v("聚集索引是索引和数据都存储在一个文件中，非聚集索引是将索引和数据分别存储在不同的文件，索引键指向的是数据文件索引所在行的数据内容。")])]),a._v(" "),v("p",[a._v("下面来解答一下几个问题。")]),a._v(" "),v("h3",{attrs:{id:"聚集索引和非聚集索引哪个效率更高"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引和非聚集索引哪个效率更高"}},[a._v("#")]),a._v(" 聚集索引和非聚集索引哪个效率更高")]),a._v(" "),v("p",[a._v("以MyISAM数据结构和InnoDB数据结构来说：")]),a._v(" "),v("p",[a._v("非聚集索引查询到索引值之后，只是拿到了索引所在行的磁盘文件地址，需要通过这个地址再进行一次I/O操作。")]),a._v(" "),v("p",[a._v("聚集索引读取到叶子节点索引值之后，即那到了索引所在行的完整的数据内容，不需要额外的I/O操作。")]),a._v(" "),v("p",[a._v("因此，聚集索引效率更高！")]),a._v(" "),v("h3",{attrs:{id:"为什么innodb必须要设置索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么innodb必须要设置索引"}},[a._v("#")]),a._v(" 为什么InnoDB必须要设置索引")]),a._v(" "),v("p",[a._v("因为InnoDB是聚集索引，索引和数据都是存到在一个文件中的，如果没有索引的话，全部数据就没办法合理的组织起来。")]),a._v(" "),v("p",[v("strong",[a._v("如果放肆，就是不加索引怎么办？")])]),a._v(" "),v("p",[a._v("如果使用InnoDB建表的时候，没有显式的指定一个主键，则会自动帮你找到一个合适的唯一索引作为主键，若找不到符合条件唯一索引条件的字段时，会生成类似于ROW_ID的虚拟列充当该表的主键。")]),a._v(" "),v("h3",{attrs:{id:"为什么主键建议设置为整型自增"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么主键建议设置为整型自增"}},[a._v("#")]),a._v(" 为什么主键建议设置为整型自增")]),a._v(" "),v("p",[a._v("在索引查找的过程中，其实做的是比对计算，通过大小比对，知道所查询的索引在什么区间范围内，从根节点进行比对，根节点没有，再到叶子节点进行比对，这个过程中，使用整型是效率比较高的一种方式。")]),a._v(" "),v("p",[a._v("如果使用的是字符串对比，例如要查找一个索引是asdf20，根节点的区间范围是asdf15~asdf56，那么查询过程中需要对asdf20进行字符串拆分，逐个逐个字符串进行比对，字符串比对过程中还需要转换成ASCII码，然后再进行大小比对，这个效率是及其底下的。")]),a._v(" "),v("p",[v("strong",[a._v("为什么要自增？")])]),a._v(" "),v("p",[a._v("在创建表之后，数据库引擎会自动将主键进行排序。我们手动的设置为自增能够，减少引擎的额外计算，要不每次添加一个数据，数据库引擎都会进行所有数据排列，当短时间内处理的数据量很大时，会损耗特别多计算量。")]),a._v(" "),v("p",[v("strong",[a._v("有序链表的好处")])]),a._v(" "),v("p",[a._v("之所以引擎会将底层叶子节点设置为有序的，是为了很好的处理一些业务场景，比如范围查找，如下面查找语句：")]),a._v(" "),v("div",{staticClass:"language-sql extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" s\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Col2 "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[a._v("20")]),a._v("\n")])])]),v("p",[a._v("查找的节点不是单一节点，而是范围节点，查找的流程就是先在根节点找到索引为20的这个节点，找到之后，向下找出其底层叶子节点，利用有序链表的特性，直接把大于20的所有数据存储到集合中，输出即可！")])])}),[],!1,null,null,null);s.default=t.exports}}]);