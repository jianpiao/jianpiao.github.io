(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{377:function(t,v,e){"use strict";e.r(v);var _=e(33),a=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue的nexttick原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的nexttick原理"}},[t._v("#")]),t._v(" Vue的nextTick原理")]),t._v(" "),e("p",[t._v("nextTick接收一个回调函数作为参数，它的作用是将回调延迟到下一次DOM更新周期之后执行。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("官网的解释：")])]),t._v(" "),e("p",[t._v("可能你还没有注意到，Vue 在更新 DOM 时是"),e("strong",[t._v("异步")]),t._v("执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 "),e("code",[t._v("Promise.then")]),t._v("、"),e("code",[t._v("MutationObserver")]),t._v(" 和 "),e("code",[t._v("setImmediate")]),t._v("，如果执行环境不支持，则会采用 "),e("code",[t._v("setTimeout(fn, 0)")]),t._v(" 代替。")])]),t._v(" "),e("p",[t._v("我们来细致的讲解一下其中的原理。")]),t._v(" "),e("h3",{attrs:{id:"为什么vue-js使用异步更新队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么vue-js使用异步更新队列"}},[t._v("#")]),t._v(" 为什么vue.js使用异步更新队列")]),t._v(" "),e("p",[t._v("vue2.0使用虚拟DOM进行渲染，变化侦测的通知只发送到组件，组件内用到的所有状态都会通知同一个watcher，然后虚拟DOM会对整个组件进行比对（diff），并更改DOM，也就是说，如果同一轮事件循环中，有两个数据发送了变化，那么组件的watcher会收到两份通知，从而进行两次渲染，事实上，并不需要渲染两次，虚拟DOM会对整个组件进行渲染，所以，只需要等所有状态都修改完毕后，一次性将整个组件的DOM渲染到最新即可。")]),t._v(" "),e("p",[t._v("要解决这个问题，vue.js的实现方式是将收到通知watcher实例添加到队列中缓存起来，并且在添加到队列之前检查其中是否已经存在相同watcher，只有不存在时，才将watcher实例添加到队列中。然后下一次事件循环（event loop）中，vue.js会让队列中的watcher触发渲染流程并清空队列。这样就可以保证即便在同一事件循环中有两个状态发生了变化，watcher最后也只执行一次渲染流程。")]),t._v(" "),e("h3",{attrs:{id:"什么是事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是事件循环"}},[t._v("#")]),t._v(" 什么是事件循环")]),t._v(" "),e("p",[t._v("JavaScript是一门单线程并且非阻塞的脚本语言，这意味着JavaScript代码在执行的任何时候只有一个主线程来处理所有任务。而非阻塞是指当前代码需要处理异步任务时，主线程会挂起(pending)这个任务，当异步任务处理完毕后，主线程再根据一定规则取执行相应回调。")]),t._v(" "),e("p",[t._v("事实上，当任务处理完毕后，JavaScript会将这个事件加入一个队列中，我们称这个队列为"),e("strong",[t._v("事件队列")]),t._v("。被放入事件队列中的事件不会立刻执行回调，而是等待当前执行栈中的所有任务执行完毕后，主线程会去查找事件队列中是否有任务。")]),t._v(" "),e("p",[t._v("异步任务有两个类型，一种是微任务(microtask)和宏任务(macortask)。不同类型的任务会被分配到不同的任务队列中。")]),t._v(" "),e("p",[t._v("当执行栈中的所有任务都执行完毕后，会去检查微任务队列中是否有事件存在，如果存在，则会依次执行微任务队列中事件对应的回调，直到为空。然后去执行宏任务队列中取出一个事件，把对应的回调加入当前执行栈，当执行栈中的所有任务都执行完毕后，检查微任务队列中是否有事件存在。无限重复此过程，就形成了一个无限循环，这个循环叫做"),e("strong",[t._v("事件循环")]),t._v("。")]),t._v(" "),e("p",[t._v("属于微任务的事件有如下：")]),t._v(" "),e("ul",[e("li",[t._v("Promise.then")]),t._v(" "),e("li",[t._v("MutationObserver")]),t._v(" "),e("li",[t._v("Object.observe")]),t._v(" "),e("li",[t._v("Process.nextTick")])]),t._v(" "),e("p",[t._v("属于宏任务事件有如下：")]),t._v(" "),e("ul",[e("li",[t._v("setTimeout")]),t._v(" "),e("li",[t._v("setInterval")]),t._v(" "),e("li",[t._v("setImmediate")]),t._v(" "),e("li",[t._v("MessageChannel")]),t._v(" "),e("li",[t._v("requestAnimationFrame")]),t._v(" "),e("li",[t._v("I/O")]),t._v(" "),e("li",[t._v("UI交互事件")])]),t._v(" "),e("h3",{attrs:{id:"什么是执行栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是执行栈"}},[t._v("#")]),t._v(" 什么是执行栈")]),t._v(" "),e("p",[t._v("当我们执行一个方法时，JavaScript会生成一个与这个方法对应的执行环境（context），又叫做执行上下文。这个执行环境中有这个方法是私有作用域、上层作用域的指向、方法的参数、私有作用域中定义的变量以及this对象。这个执行环境会被添加到一个栈中，这个栈就是执行栈。")]),t._v(" "),e("p",[t._v("如果这个方法的代码中执行到了一行函数调用语句，那么JavaScript会生成这个函数的执行环境并将其添加到执行栈中，然后进入这个执行环境继续执行其中的代码。执行完毕并返回结果后，JavaScript会退出执行环境并把这个执行环境从栈中销毁，回到上一个方法的执行环境。这个过程反复进行，知道执行环境中的代码全部执行完毕，这个执行环境的栈就是执行栈。")]),t._v(" "),e("h3",{attrs:{id:"nexttick的异步更新策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的异步更新策略"}},[t._v("#")]),t._v(" nextTick的异步更新策略")]),t._v(" "),e("p",[t._v("nextTick其实是将回调添加到微任务中，只有在特殊的情况才会降级成宏任务，默认会添加到微任务中。")]),t._v(" "),e("p",[t._v("因此，如果使用nextTick来获取更新后的DOM，则需要注意顺序的问题。因为不论是更新DOM的回调还是使用nextTick注册的回调，都是向微任务队列中添加任务，所有哪个任务先添加到队列中，就先执行哪个任务。")])])}),[],!1,null,null,null);v.default=a.exports}}]);